<a id="mulu">目录</a>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [线性表](#线性表)
    - [定义](#定义)
    - [线性表的顺序存储实现](#线性表的顺序存储实现)
    - [线性表的链式存储实现](#线性表的链式存储实现)
    - [广义表和多重链表](#广义表和多重链表)
- [堆栈](#堆栈)
    - [存储方式](#存储方式)
    - [应用：后缀表达式求值](#应用后缀表达式求值)
- [队列](#队列)
    - [存储](#存储)
- [应用](#应用)
    - [一元多项式的加法与乘法运算](#一元多项式的加法与乘法运算)
    - [两个有序链表合并](#两个有序链表合并)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 线性表
如何表示多项式f(x)=a~0~+a~1~x+...+a~n-1~x^n-1^+a~n~x^n^
多项式的关键数据：多项式项数n、各项系数a~i~
1. 顺序存储结构直接表示：数组各分量对应多项式各项，a[i]为各项系数
例如：f(x)=4x^5^-3x^2^+1可表示成
![顺序存储结构直接表示](https://img-blog.csdnimg.cn/20210517211307499.png#pic_center "顺序存储结构直接表示")
两个多项式相加就是两个数组对应分量相加。
问题在于：当表示如f(x)=x+3x^2000^这种多项式时内存浪费
2. 顺序存储结构表示非零项：每个非零项包含系数a~i~和指数i两个信息，可以将多项式看出一个(a~i~,i)二元组的集合
例如：P~1~(x)=9x^12^+15x^8^+3x^2^和P~2~(x)=26x^19^-4x^8^-13x^6^+82可表示成
![顺序存储结构表示非零项](https://img-blog.csdnimg.cn/20210517211339498.png#pic_center "顺序存储结构表示非零项")
即按指数大小有序存储
相加过程：从头开始，比较两个多项式当前对应项的指数，若相同，将系数相加；不相同就保留
3. 链表结构存储非零项：链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域。
例如：P~1~(x)=9x^12^+15x^8^+3x^2^和P~2~(x)=26x^19^-4x^8^-13x^6^+82可表示成：
![链表结构存储非零项](https://img-blog.csdnimg.cn/20210517213000699.png#pic_center "链表结构存储非零项")

总结：
- 同一个问题可以有不同的表示（存储）方法；
- 有一类共性问题：有序线性序列的组织和管理。
##### 定义
一个线性表是n个具有**相同特性**的数据元素的**有限**序列。
线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是**首尾相接**的（只适用大部分线性表，而不是全部。如循环链表的尾指针指向了首位结点）
表中元素个数称为**线性表的长度**；线性表没有元素时，称为**空表**； 表起始位置称为**表头**，表结束位置称**表尾**。
##### 线性表的顺序存储实现
利用数组的连续存储空间存放线性表的各元素。线性表的顺序存储中的下标从0开始。
![线性表的顺序存储实现](https://img-blog.csdnimg.cn/2021051721530066.png#pic_center "线性表的顺序存储实现")
```
struct LNode{
    ElementType Data[MAXSIZE]; //用于储存数据的数组
    int Last; //数组的最大索引，即该表的长度为last+1
};
```
##### 线性表的链式存储实现
不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系。插入、删除不需要移动数据元素，只需要修改“链”。
```
struct LNode{
    ElementType Data;  //节点对应的数据
    List Next;  //下一个节点的位置
};
```
这种方式和链表几乎相同，都是分成数据域和指针域
##### 广义表和多重链表
广义表是线性表的推广。对于线性表而言，n个元素都是基本的单元素；广义表中，这些元素不仅可以是单元素也可以是另一个广义表。
多重链表：链表中的节点可能同时隶属于多个链。即多重链表中结点的指针域会有多个；但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表。
多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储。
[回到目录](#mulu)
### 堆栈
栈(stack)又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。
这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
因为栈只在栈顶进行数据操作，所以它是**先进后出、后进先出**的
![堆栈示例](https://img-blog.csdnimg.cn/20210519173053851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "堆栈示例"){:width=300px height=300px}
##### 存储方式
1. 顺序存储：由一个一维数组和一个记录栈顶元素位置的变量组成。
```
struct SNode{
    ElementType Data[MaxSize]; //栈数据存储
    int Top; //栈顶元素的索引
}
```
例：用一个数组实现两个堆栈，要求最大地利用数组空间
--使这两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都满了。
2. 链式存储：实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行（链表的尾端）
##### 应用：后缀表达式求值
后缀表达式：运算符号位于两个运算数之后，如`62/3-42*+` 
计算方法：先读取两个数`6` `2`，碰到了`/`，就是`6/2`，变成`33-42*+`；
再读取两个数`3` `3`，碰到了`-`，就是`3-3`，变成`042*+`；
对于有3个数的情况，先读取`*`号，前面的两个数为`4` `2`，就是`4*2`，变成`08+`，即`0+8=8`
从此可以总结出后缀表达式求值的规律：
1. 运算数：入栈
2. 运算符：从栈中弹出适当数量的运算数，计算结果入栈
3. 最后栈顶上的元素就是表达式的结果值
### 队列
队列(queue)是一种特殊的线性表，特殊之处在于它只允许在表的前端(front)进行删除操作（出队列），而在表的后端(rear)进行插入操作（进队列）。和栈一样，队列是一种操作受限制的线性表。
进行插入操作的端称为队尾，进行删除操作的端称为队头。
因此队列是**先进先出、后进后出**的
##### 存储
1. 顺序存储：由一个一维数组和一个记录队列头元素位置的变量`front`以及一个记录队列尾元素位置的变量`rear`组成。
```
struct QNode {
    ElementType Data[ MaxSize ];
    int rear;
    int front;
}
```
最开始这两个变量都为0，加入一个元素时rear加1（元素被加到新rear的位置上），删除一个元素时front加1（原front位置上的元素被删除）。
这样可能导致rear已经到数组最大值了，加不进去，但是数组前面还是空的。
2. 顺环队列：把这个数组头尾相接，形成一个环，最开始的时候front=rear，假设一共有6个位置，则front与rear的差值也是从0-5（共6种情况），而队列中含有元素的数量是0-6（共7种情况）所以不能用它们的差值判断队列是空的还是满的（当没有元素或有6个元素时front都=rear）。
解决办法：使用一个额外的size记录元素数量，或者仅使用5个数组空间进行存储（此时除了队列为空，front都不可能=rear）
3. 链式存储：用一个单链表实现。插入和删除操作分别在链表的两头进行（链表头删除，尾插入）
```
struct Node{ //队列节点
    ElementType Data;
    struct Node *Next;
}
struct QNode{  //链队列结构
    struct Node *rear;  //指向队尾结点
    struct Node *front;  //指向队头结点
}
```
### 应用
##### 一元多项式的加法与乘法运算
输入：分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
***
加法及录入数据：
声明变量：n和m3代表两个多项式非0项的个数；a和b存储非零项系数，a1和b1存储对应的指数；d代表用顺序储存结构存储的加法运算结果数组，即d[i]表示指数为i项的系数
```
cin >> n;
for (i = 0; i < n; i++)
{
	cin >> a[i] >> a1[i]; 
	d[a1[i]] += a[i]; //这里直接把加法算了
}
cin >> m3;
for (i = 0; i < m3; i++)
{
	cin >> b[i] >> b1[i];
	d[b1[i]] += b[i]; //这里直接把加法算了
}
```
***
乘法：
声明变量：c存储乘完后多项式的系数，c1存储对应的指数；h用顺序储存结构存储的乘法运算结果数组
```
k = 0; //k表示该次循环的结果应存入c和c1的索引
for (i = 0; i < n; i++)
{
	for (j = 0; j < m3; j++)
	{
		c[k] = a[i] * b[j];
		c1[k] = a1[i] + b1[j]; //多项式相乘，系数相乘，指数相加；
		h[c1[k]] += c[k]; 
		k++;
	}
}
```
***
若让指数从大到小输出，就遍历两个结果数组，从它们的尾部开始，如果储存的系数不是0就输出索引（指数）和值（系数）
##### 两个有序链表合并
