<a id="mulu">目录</a>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [线性表](#线性表)
    - [定义](#定义)
    - [线性表的顺序存储实现](#线性表的顺序存储实现)
    - [线性表的链式存储实现](#线性表的链式存储实现)
    - [广义表和多重链表](#广义表和多重链表)
- [堆栈](#堆栈)
    - [存储方式](#存储方式)
    - [应用：后缀表达式求值](#应用后缀表达式求值)
- [队列](#队列)
    - [存储](#存储)
- [应用](#应用)
    - [一元多项式的加法与乘法运算](#一元多项式的加法与乘法运算)
    - [两个有序链表合并](#两个有序链表合并)
    - [颠倒链表](#颠倒链表)
      - [录入数据及有效数据统计](#录入数据及有效数据统计)
      - [头插法反转链表](#头插法反转链表)
    - [出栈的可能顺序](#出栈的可能顺序)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 线性表
如何表示多项式f(x)=a~0~+a~1~x+...+a~n-1~x^n-1^+a~n~x^n^
多项式的关键数据：多项式项数n、各项系数a~i~
1. 顺序存储结构直接表示：数组各分量对应多项式各项，a[i]为各项系数
例如：f(x)=4x^5^-3x^2^+1可表示成
![顺序存储结构直接表示](https://img-blog.csdnimg.cn/20210517211307499.png#pic_center "顺序存储结构直接表示")
两个多项式相加就是两个数组对应分量相加。
问题在于：当表示如f(x)=x+3x^2000^这种多项式时内存浪费
2. 顺序存储结构表示非零项：每个非零项包含系数a~i~和指数i两个信息，可以将多项式看出一个(a~i~,i)二元组的集合
例如：P~1~(x)=9x^12^+15x^8^+3x^2^和P~2~(x)=26x^19^-4x^8^-13x^6^+82可表示成
![顺序存储结构表示非零项](https://img-blog.csdnimg.cn/20210517211339498.png#pic_center "顺序存储结构表示非零项")
即按指数大小有序存储
相加过程：从头开始，比较两个多项式当前对应项的指数，若相同，将系数相加；不相同就保留
3. 链表结构存储非零项：链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域。
例如：P~1~(x)=9x^12^+15x^8^+3x^2^和P~2~(x)=26x^19^-4x^8^-13x^6^+82可表示成：
![链表结构存储非零项](https://img-blog.csdnimg.cn/20210517213000699.png#pic_center "链表结构存储非零项")

总结：
- 同一个问题可以有不同的表示（存储）方法；
- 有一类共性问题：有序线性序列的组织和管理。
##### 定义
一个线性表是n个具有**相同特性**的数据元素的**有限**序列。
线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是**首尾相接**的（只适用大部分线性表，而不是全部。如循环链表的尾指针指向了首位结点）
表中元素个数称为**线性表的长度**；线性表没有元素时，称为**空表**； 表起始位置称为**表头**，表结束位置称**表尾**。
[回到目录](#mulu)
##### 线性表的顺序存储实现
利用数组的连续存储空间存放线性表的各元素。线性表的顺序存储中的下标从0开始。
![线性表的顺序存储实现](https://img-blog.csdnimg.cn/2021051721530066.png#pic_center "线性表的顺序存储实现")
```
struct LNode{
    ElementType Data[MAXSIZE]; //用于储存数据的数组
    int Last; //数组的最大索引，即该表的长度为last+1
};
```
##### 线性表的链式存储实现
不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系。插入、删除不需要移动数据元素，只需要修改“链”。
```
struct LNode{
    ElementType Data;  //节点对应的数据
    List Next;  //下一个节点的位置
};
```
这种方式和链表几乎相同，都是分成数据域和指针域
##### 广义表和多重链表
广义表是线性表的推广。对于线性表而言，n个元素都是基本的单元素；广义表中，这些元素不仅可以是单元素也可以是另一个广义表。
多重链表：链表中的节点可能同时隶属于多个链。即多重链表中结点的指针域会有多个；但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表。
多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储。
[回到目录](#mulu)
### 堆栈
栈(stack)又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。
这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
因为栈只在栈顶进行数据操作，所以它是**先进后出、后进先出**的
![堆栈示例](https://img-blog.csdnimg.cn/20210519173053851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "堆栈示例"){:width=300px height=300px}
##### 存储方式
1. 顺序存储：由一个一维数组和一个记录栈顶元素位置的变量组成。
```
struct SNode{
    ElementType Data[MaxSize]; //栈数据存储
    int Top; //栈顶元素的索引
}
```
例：用一个数组实现两个堆栈，要求最大地利用数组空间
--使这两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都满了。
2. 链式存储：实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行（链表的尾端）
##### 应用：后缀表达式求值
后缀表达式：运算符号位于两个运算数之后，如`62/3-42*+` 
计算方法：先读取两个数`6` `2`，碰到了`/`，就是`6/2`，变成`33-42*+`；
再读取两个数`3` `3`，碰到了`-`，就是`3-3`，变成`042*+`；
对于有3个数的情况，先读取`*`号，前面的两个数为`4` `2`，就是`4*2`，变成`08+`，即`0+8=8`
从此可以总结出后缀表达式求值的规律：
1. 运算数：入栈
2. 运算符：从栈中弹出适当数量的运算数，计算结果入栈
3. 最后栈顶上的元素就是表达式的结果值

[回到目录](#mulu)
### 队列
队列(queue)是一种特殊的线性表，特殊之处在于它只允许在表的前端(front)进行删除操作（出队列），而在表的后端(rear)进行插入操作（进队列）。和栈一样，队列是一种操作受限制的线性表。
进行插入操作的端称为队尾，进行删除操作的端称为队头。
因此队列是**先进先出、后进后出**的
##### 存储
1. 顺序存储：由一个一维数组和一个记录队列头元素位置的变量`front`以及一个记录队列尾元素位置的变量`rear`组成。
```
struct QNode {
    ElementType Data[ MaxSize ];
    int rear;
    int front;
}
```
最开始这两个变量都为0，加入一个元素时rear加1（元素被加到新rear的位置上），删除一个元素时front加1（原front位置上的元素被删除）。
这样可能导致rear已经到数组最大值了，加不进去，但是数组前面还是空的。
2. 顺环队列：把这个数组头尾相接，形成一个环，最开始的时候front=rear，假设一共有6个位置，则front与rear的差值也是从0-5（共6种情况），而队列中含有元素的数量是0-6（共7种情况）所以不能用它们的差值判断队列是空的还是满的（当没有元素或有6个元素时front都=rear）。
解决办法：使用一个额外的size记录元素数量，或者仅使用5个数组空间进行存储（此时除了队列为空，front都不可能=rear）
3. 链式存储：用一个单链表实现。插入和删除操作分别在链表的两头进行（链表头删除，尾插入）
```
struct Node{ //队列节点
    ElementType Data;
    struct Node *Next;
}
struct QNode{  //链队列结构
    struct Node *rear;  //指向队尾结点
    struct Node *front;  //指向队头结点
}
```
[回到目录](#mulu)
### 应用
##### 一元多项式的加法与乘法运算
输入：分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
***
加法及录入数据：
声明变量：n和m3代表两个多项式非0项的个数；a和b存储非零项系数，a1和b1存储对应的指数；d代表用顺序储存结构存储的加法运算结果数组，即d[i]表示指数为i项的系数
```
cin >> n;
for (i = 0; i < n; i++)
{
	cin >> a[i] >> a1[i]; 
	d[a1[i]] += a[i]; //这里直接把加法算了
}
cin >> m3;
for (i = 0; i < m3; i++)
{
	cin >> b[i] >> b1[i];
	d[b1[i]] += b[i]; //这里直接把加法算了
}
```
***
乘法：
声明变量：c存储乘完后多项式的系数，c1存储对应的指数；h用顺序储存结构存储的乘法运算结果数组
```
k = 0; //k表示该次循环的结果应存入c和c1的索引
for (i = 0; i < n; i++)
{
	for (j = 0; j < m3; j++)
	{
		c[k] = a[i] * b[j];
		c1[k] = a1[i] + b1[j]; //多项式相乘，系数相乘，指数相加；
		h[c1[k]] += c[k]; 
		k++;
	}
}
```
***
若让指数从大到小输出，就遍历两个结果数组，从它们的尾部开始，如果储存的系数不是0就输出索引（指数）和值（系数）
[回到目录](#mulu)
##### 两个有序链表合并
将两个链表表示的递增整数序列合并为一个非递减的整数序列。
思路：双指针分别指向两个链表，从前往后移动，当`p1<p2`时将p1加入到结果链表中 同时p1向后移，否则p2放入结果链表中 同时p2向后移。
```
List Merge(List L1, List L2)
{
	List pa, pb, pc;
	List L = (List)malloc(sizeof(struct Node));
	pa = L1->Next;
	pb = L2->Next;
	pc = L; //结果链表的指针，开始时指向头节点
	while (pa && pb)
	{
		if (pa->Data <= pb->Data)
		{
			pc->Next = pa; //pa指向的节点放入结果链表中
			pc = pa;
			pa = pa->Next; //pa向后移动
		}
		else
		{
			pc->Next = pb;
			pc = pb;
			pb = pb->Next;
		}
	}
	pc->Next = pa ? pa : pb;  //如果pa不为空，pc->Next = pa，否则pc->Next = pb
	L1->Next = NULL;
	L2->Next = NULL;
	return L;
}
```
[回到目录](#mulu)
##### 颠倒链表
给定一个常数K和一个单链表L，把L上所有K个元素的链接都颠倒过来。例如，给定L为1→2→3→4→5→6，如果K=3，那么输出3→2→1→6→5→4；如果K=4，输出4→3→2→1→5→6。即每K个节点反转一次。
输入：第一行为`第一个节点地址 结点总数 K`，剩下每一行描述一个结点的格式为`Address Data Next`，其中Address是结点的位置，Data是一个整数，Next是下一个节点的位置。颠倒时要将数据和地址同时颠倒如：
```
00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
```
显然这是一个未排列好的链表，正常情况一个节点的next值=下一个节点的address。
###### 录入数据及有效数据统计
录入数据：直接采用稀疏数组，创建一个结点数组，题中给的地址作为索引存储节点
```
typedef struct node {
	ElementType data;
	ElementType next;
} Node; //节点定义，包括数据和next值
Node list[MAXSIZE];
int Head, N, K;  //Head为第一个结点的地址,N为结点的总数，K为要反转的子列表的长度
cin >> Head >> N >> K;
int i, Address, Data, Next;  //Address是结点的位置，Data是一个整数，Next是下一个结点的位置
for (i = 0; i < N; i++) 
{
	cin >> Address >> Data >> Next;
	list[Address].data = Data;
	list[Address].next = Next;
}
int num = 1;//所给数据结点并不都是链表中的结点，用于计数真正的结点个数 
while (list[next].next != -1) {
	num++;
	next = list[next].next;
}
```
###### 头插法反转链表
头插法--在插入时，新的结点插入到当前链表的表头：
`1 2 3 4`四个节点，`for(int i=1;i<=4;i++)`让第i个节点插入到这个链表的最前面。`1 2 3 4`->`2 1 3 4`->`3 2 1 4`->`4 3 2 1`。关键点在于新创建的节点要指向原第一个节点，头节点指向这个新创建的节点。
而
一个简单的例子：
```
STU*p=phead->next; //p是头节点后的第一个节点（有数据的第一个节点），以下简称为第一个节点
phead->next=NULL; //断开头节点与后面节点的连接
STU*q; //保存p后的那个节点
//p始终指向要插入到头部的那个节点，phead始终指向头节点
while(p!=NULL){
	q=p->next; //q保存要插入到头部的那个节点之后的那个节点地址（因为下一次循环要把它插入到头部，这里必须保存，要不待会改p->next就获取不到这个节点了）
	p->next=phead->next; //phead->next为原第一个节点地址，要插入到头部的那个节点 的next应为原来的第一个节点地址
	phead->next=p; //更改第一个节点为p
	p=q; //确定下一个要移动的节点
}
```
[回到目录](#mulu)
***
下面做法更改了确定下一个要移动的节点的方法，观察`1 2 3 4`->`2 1 3 4`->`3 2 1 4`->`4 3 2 1`可知，要移动的节点始终使最开始的第一个节点`1`的下一个节点。
```
int K,head,N; //head为第一个结点的地址,N为结点的总数，K为要反转的子列表的长度
int flag = 1; //是否为第一次翻转
int last_head; //用于记录上一次反转后，子链表的最后结点地址，待与下一次反转的子链表的头部相连
int rev_head = head; //下一次待反转子链表的头结点地址
int mid_head = head; //反转过程中的中间结点地址
while (N - K >= 0) //当剩余结点不够K个时，则不再反转 
{
	N -= K;
	//反转子链表 
	for (int i = 0; i < K - 1; i++) 
	{
        //rev_head始终指向原第一个节点，它的next（mid_next）就是要移动的那个节点的地址
		mid_next = list[rev_head].next;
		list[rev_head].next = list[mid_next].next; //使要移动的那个节点之前的节点rev_head的next值为要移动的那个节点之后的那个节点的地址list[mid_next].next
		list[mid_next].next = mid_head; //要移动的那个节点的next指向头节点
		mid_head = mid_next; //更新头节点地址
	}//反转子链表
	if (flag == 0) //从第二次开始，需要把这次反转后的子链表的头结点连接到上一段的尾部 
	{
		list[last_head].next = mid_head;
	}
	if (flag) //记录第一次反转后的头结点，作为最终List的头结点并返回 
	{
		head = mid_head;
		flag = 0;
	}
	last_head = rev_head;
	rev_head = list[rev_head].next;//下次开始的头结点地址 
	mid_head = rev_head;
}
```
[回到目录](#mulu)
##### 出栈的可能顺序
给出若干序列，检测每个序列（每个数字池）能否通过指定大小的栈pop得到，入栈顺序：1,2,...,N。
输入第一行：M（栈的最大容量）、N（要检测的数字有多少个）、K（有多少组要检测的数字）；后K行每行N个数字，代表要检测的数组；输出：如果可以通过栈的pop得到则输出YES，否则输出NO。

思路:不是找不能/可以出栈的序列规律，而是对每一个给定序列进行模拟，来判断是否可行。
给定数列是通过在1、2...依次入栈的过程中，在某个数入栈后立即抛出，之后要么接着抛出栈中的下一个数，要么继续入栈过程。
要想逆推这个过程，就需要我们把数依次入栈，同时比较这个数与给定序列的第一个数，若相等就抛出、并接着比较栈内的下一个数与给定序列的下一个数，若不等就继续入栈。
直至全部比较完成——该序列满足条件，或者入栈过程中栈内元素数量超过了M/未全部比较完成而入栈过程已完毕——不满足条件
```
int M, N, K;
cin >> M >> N >> K;
while (K--)   //k是总共需要判断的序列数量，k--控制判断次数
{
	vector<int> pool(N, 0); 
	for (int i = 0; i < N; ++i) //输入一个数字池
		cin >> pool[i];
	int flag = 1, ru_zhan = 1; //ru_zhan是入栈的那个数
	int pa = 0; //pool中元素的索引
	stack<int> stack_now;
	while (ru_zhan <= N) //最后一个入栈的数是N
	{
		stack_now.push(ru_zhan); //入栈一个数
		ru_zhan++; //下一个要入栈的数比当前大1
		if (stack_now.size() > M) //如果栈中的元素数量超过了最大允许元素数，就不行。注意这里不是栈顶值比M大，而是数量
		{
			flag = 0;
			break;
		}
		while (!stack_now.empty() && pa < N && pool[pa] == stack_now.top())//当栈顶元素等于要验证的第pa个pool中元素，且pa在规定范围内（未验证完）时，
		{
			pa++;//该元素验证成功，该验证下一个元素
			stack_now.pop();//栈顶元素被抛出
		}//这里要用循环，因为可能入栈一个元素但抛出多个元素
	}
	if (pa < N) flag = 0;  //未验证完，不行
	if (flag==0) cout << "NO" << endl;
	else cout << "YES" << endl;
}
return 0;
```
[回到目录](#mulu)