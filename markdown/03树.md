<a id="mulu">目录</a>
<a class="back" href="#mulu" style="width:40px;height:40px;display:inline-block;font-size:20px;line-height:20px;background-color:lightyellow;color:green;position: fixed;bottom: 50px;right: 50px;z-index: 999;border:2px solid pink;opacity:0.5;">回到目录</a>
<style>
    .back:hover{color:red;}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [树](#树)
    - [定义](#定义)
    - [表示](#表示)
- [二叉树](#二叉树)
    - [定义](#定义-1)
    - [性质](#性质)
    - [存储](#存储)
      - [顺序存储结构](#顺序存储结构)
      - [链表存储结构](#链表存储结构)
    - [递归遍历](#递归遍历)
      - [先序遍历](#先序遍历)
      - [中序遍历](#中序遍历)
      - [后序遍历](#后序遍历)
    - [非递归遍历](#非递归遍历)
      - [中序遍历](#中序遍历-1)
      - [先序遍历](#先序遍历-1)
      - [后序遍历](#后序遍历-1)
      - [层序遍历](#层序遍历)
    - [遍历的应用](#遍历的应用)
      - [输出叶子节点](#输出叶子节点)
      - [求树高度](#求树高度)
      - [二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
      - [由两种遍历序列确定二叉树](#由两种遍历序列确定二叉树)
- [二叉搜索树](#二叉搜索树)
    - [查找](#查找)
      - [查找指定元素](#查找指定元素)
      - [查找最大和最小元素](#查找最大和最小元素)
    - [插入](#插入)
    - [删除](#删除)
- [平衡二叉树](#平衡二叉树)
    - [平衡二叉树的调整](#平衡二叉树的调整)
      - [RR旋转](#rr旋转)
      - [LL旋转](#ll旋转)
      - [LR旋转](#lr旋转)
      - [RL旋转](#rl旋转)
    - [AVL树的根](#avl树的根)
- [堆](#堆)
    - [最大堆操作](#最大堆操作)
      - [初始化](#初始化)
      - [插入](#插入-1)
      - [删除](#删除-1)
      - [建立](#建立)
- [哈夫曼树和哈夫曼编码](#哈夫曼树和哈夫曼编码)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 树
##### 定义
树(Tree) ：n(n≥0)个结点构成的有限集合。当n=0时，称为空树。
对于任一棵非空树(n>0)，它具备以下性质：
- 树中有一个称为“根(Root)”的特殊结点，用r表示；
- 其余结点可分为m(m>0)个互不相交的有限集T1、T2、...Tm，其中每个集合本身又是一棵树，称为原来树的“子树”(subTree)
![树的定义](https://img-blog.csdnimg.cn/20210521103757235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "树的定义"){:width=150px height=150px}
***
如何判断一个结构是不是树：
- 子树是不相交的；
- 除了根结点外，每个结点有且仅有一个父结点；
- 一棵N个结点的树有N-1条边。

一些非树的例子：
![非树的例子](https://img-blog.csdnimg.cn/20210521104042831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "非树的例子"){:width=150px height=150px}
***
树的一些相关定义：
- 结点的度(Degree)：结点的子树个数
- 树的度：树的所有结点中最大的度数
- 叶结点(leaf)：度为0的结点，即树最底层的节点，没有子树
- 父结点(parent)：有子树的结点是其子树的根节点的父结点
- 子结点（孩子结点）(child)：若A结点是B结点的父节点，则称B结点为A结点的子结点
- 兄弟结点(sibling)：具有同一父结点的各结点彼此是兄弟结点
- 路径和路径长度：从结点n1到nk的路径为一个结点序列n~1~,n~2~,...,n~k~（其中n~i~是n~i+1~的父结点）；路径所包含边的个数为路径的长度
- 祖先结点(ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
- 子孙结点(descendant)：某一结点的子树中的所有结点是这个结点的子孙
- 结点的层次(level)：规定根结点在1层，其他任一结点的层数是其父结点的层数加1
- 树的深度(depth)：树中所有结点中的最大层次
##### 表示
1. 使用链表：
    i. 一个结点有几个子节点，它就有几个指针，但这种结构中每个结点的指针域都不同
    ![树的链表表示法](https://img-blog.csdnimg.cn/20210521105620946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "树的链表表示法"){:width=150px height=150px}
    ii. 把所有结点的指针个数都设为同一值，即子树的最大个数。子树数量少的结点中把没用的指针设为null，但这样会多使用指针，造成空间上的浪费
2. 儿子-兄弟表示法：每个结点都有两个指针，一个指针指向第一个儿子FirstChild，另一个指针指向下一个兄弟NextSibling。
    好处：树中所有结点的结构是统一的，都为两个指针域；如果树有n个结点，则树就有2n个指针域，树有n-1条边，所有就有n-1个指针域是空的，造成空间上的浪费也不大。
    ![树的儿子-兄弟表示法](https://img-blog.csdnimg.cn/20210521110202824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_14,color_FFFFFF,t_70#pic_center "树的儿子-兄弟表示法"){:width=150px height=150px}

将上述所示的儿子-兄弟表示法表示的树，顺时针旋转45°，一个指针指向左子树Left（左儿子），另一个指针指向右子树Right（右儿子）。
![树的儿子-兄弟表示法2](https://img-blog.csdnimg.cn/20210521111155275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "树的儿子-兄弟表示法2"){:width=150px height=150px}
### 二叉树
##### 定义
二叉树：一个有穷的结点集合，这个集合可以为空；若不为空，则它是由根节点和被称为左子树Tl和右子树Tr的两个不相交的二叉树组成，是有序树。
共有5种形态：空、只有一个节点、左子树为空、右子树为空、左右子树都有（都不为空）。
**特点**是每个结点最多只能有两棵子树，且有左右之分。
***
特殊二叉树：
1. 斜二叉树：只有左儿子或者只有右儿子，就相当于一个链表
![斜二叉树](https://img-blog.csdnimg.cn/20210521151718817.png#pic_center "斜二叉树"){:width=150px height=150px}
2. 完美二叉树（满二叉树）：每个节点都有两个儿子（除了最底层的叶节点），且层数n与该层内结点数N满足：`N=2^(n-1)` 即都是`1->2->4->8.....`这种
![完美二叉树](https://img-blog.csdnimg.cn/20210521151805389.png#pic_center "完美二叉树"){:width=150px height=150px}
3. 完全二叉树：有n个节点的二叉树，对树中节点按从上至下、从左至右的顺序编号，编号为i的节点与满二叉树中编号为i的节点在二叉树中的位置相同，即它的倒数第二层往上与完美二叉树相同，最后一层中允许缺最右面开始往左的多个节点，但最左面与完美二叉树对齐
![完全二叉树](https://img-blog.csdnimg.cn/20210521154402495.png#pic_center "完全二叉树"){:width=150px height=150px}
##### 性质
- 一个二叉树第i层的最大结点数为2^i-1^,(i>=1)
- 深度为k kk的二叉树有最大结点总数为2^k^-1,(k>1)
- 对任何非空二叉树，若n~0~表示叶节点个数，n~2~是度为2的非叶节点个数，则n~0~=n~2~+1。
因为`总边数`=`总节点数(n0+n1+n2)`-1,其中n0的节点往下没有边,n1的节点有1条,n2的节点有2条
即n0+n1+n2-1=0\*n0+1\*n1+2\*n2，可得上述关系
##### 存储
###### 顺序存储结构
由于二叉树的分支少（只有两个）所以可以用数组实现，最适合的树就是完全二叉树，按从上至下、从左至右的顺序存储（1->9）
![二叉树顺序存储结构1](https://img-blog.csdnimg.cn/20210521160956161.png#pic_center "二叉树顺序存储结构1"){:width=150px height=150px}
n个结点的完全二叉树的**结点父子关系**：
- 对任一序号为`i`的非根节点，其父结点的序号是`i/2`
- `i`节点的左儿子序号是`2i`，右儿子的序号是`2i+1`；`2i<=n`时`i`有左儿子，`2i+1<=n`时有右儿子（n为节点总数）
对于一般的二叉树，也可以用数组实现，但需要对其进行补充，使其称为完全二叉树，造成空间浪费：
![二叉树顺序存储结构2](https://img-blog.csdnimg.cn/20210521162010460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉树顺序存储结构2"){:width=200px height=200px}
###### 链表存储结构
每个节点有三个元素，一个是数据，另外两个是左指针和右指针
```
struct tree_node
{
	int data;
	struct tree_node* left;
	struct tree_node* right;
};
```
如下图左边所示的二叉树，链表存储结构如右边所示：
![二叉树链表存储结构](https://img-blog.csdnimg.cn/20210521162601674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉树链表存储结构"){:width=200px height=200px}
##### 递归遍历
###### 先序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
访问根节点->遍历其左子树->遍历其右子树
```
void pre_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		printf("%d", root->data);
		pre_order_traversal(root->left);
		pre_order_traversal(root->right);
	}
}
```
![先序遍历](https://img-blog.csdnimg.cn/20210521163649704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "先序遍历"){:width=150px height=150px}
上图所示的二叉树先序遍历顺序：`A B D F E C G H I`。
###### 中序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
遍历其左子树->访问根节点->遍历其右子树
```
void in_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		in_order_traversal(root->left);
		printf("%d", root->data);
		in_order_traversal(root->right);
	}
}
```
![中序遍历](https://img-blog.csdnimg.cn/20210521164551359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "中序遍历"){:width=150px height=150px}
上图所示的二叉树中序遍历顺序：`D B E F A G H C l`。
###### 后序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
遍历其左子树->遍历其右子树->访问根节点
```
void post_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		post_order_traversal(root->left);
		post_order_traversal(root->right);
		printf("%d", root->data);
	}	
}
```
![后序遍历](https://img-blog.csdnimg.cn/20210521165033198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "后序遍历"){:width=150px height=150px}
上图所示的二叉树后序遍历顺序：`D E F B H G I C A`。
***
对于递归的先中后序遍历，它们过程中经过节点的路径一样，只是访问(printf)各节点的时机不同。
##### 非递归遍历
非递归算法实现的**基本思路：使用堆栈**。
###### 中序遍历
遇到一个节点，就把它压入栈中，并遍历它的左子树，当左子树遍历结束后，从栈顶抛出这个节点并printf它，然后按其右指针再去中序遍历该节点的右子树
```
void de_in_order_traversal(struct tree_node* root)
{
	struct tree_node* p = root;//辅助指针变量
	stack<tree_node*> s;
	while (p != NULL || !s.empty()) //当p为空且栈也空时退出循环
	{
		while (p != NULL)//遍历左子树，一直向左并将沿途节点压入栈中
		{
			s.push(p);
			p = p->left;  //让p指向p节点的左儿子
		}
		if (!s.empty())
		{
			printf("%5d", s.top()->data);//打印栈顶节点
			p = s.top();
			s.pop();  //抛出该节点
			p = p->right;//p指向原栈顶节点的右节点（转向右子树）
		}
	}
}
```
###### 先序遍历
```
void de_pre_order_traversal(struct tree_node* root)
{
	struct tree_node* p = root;//辅助指针变量
	stack<tree_node*> s;
	while (p != NULL || !s.empty()) //当p为空且栈也空时退出循环
	{
		while (p != NULL)
		{
			s.push(p); //压栈，第一次遇到该结点 
			printf("%5d", s.top()->data);
			p = p->left; //遍历左子树 
		}
		if (!s.empty())
		{
			p = s.top();
			s.pop(); //出栈，第二次遇到该结点 
			p = p->right; //访问右结点 
		}
	}
}
```
###### 后序遍历
```
void PostOrderTraversal(BinTree BT)
{
	BinTree T = BT;
	Stack S = CreateStack();  //创建并初始化堆栈S
	vector<BinTree> v;   //创建存储树结点的动态数组
	Push(S,T);
	while(!IsEmpty(S)){  //当树不为空或堆栈不空 
		T = Pop(S); //T是S中栈顶元素
		v.push_back(T);  //出栈元素进数组
		if(T->Left)
			Push(S,T->Left);
		if(T->Right)
			Push(S,T->Right);
	}
	reverse(v.begin(),v.end());  //逆转 
	for(int i=0;i<v.size();i++)  //输出数组元素
		cout << v[i]->Data << endl;
} 
```
###### 层序遍历
利用**队列**：先根结点入队，然后循环执行--
1. 从队列中取出一个元素（首元素）；                
2. 访问(printf)该元素所指结点；
3. 若该元素所指结点的左、右子结点非空，则将其左、右子结点的指针顺序入队。
```
void level_order_travelsal(struct tree_node* root)
{
	queue<struct tree_node*> q;
	struct tree_node* p; //辅助指针变量
	if (root == NULL)
		return;
	q.push(root); //根结点入队
	while (!q.empty())
	{
		p = q.front(); //从队列中取出第一个元素
		printf("%d", p->data); //访问该元素所指结点
		q.pop(); //删除刚刚取出的q.front()
        //若该元素所指结点的左、右子结点非空，则将其左、右子结点的指针顺序入队。
		if (p->left != NULL) q.push(p->left);
		if (p->right != NULL) q.push(p->right);
	}
}
```
[回到目录](#mulu)
##### 遍历的应用
###### 输出叶子节点
输出二叉树中的叶子节点（没有儿子的节点）：在二叉树遍历算法中的printf前添加条件，检测是否为叶子节点
```
void pre_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		if(root->left==NULL&&root->right==NULL)
			printf("%d", root->data);
		pre_order_traversal(root->left);
		pre_order_traversal(root->right);
	}
}
```
###### 求树高度
求二叉树的高度：用递归来做--一个二叉树的高度=max(左右两个子树的高度)+1
```
int post_order_get_height(struct tree_node* root)
{
	int left_height, right_height, max_height;
	if (root != NULL)
	{
		left_height = post_order_get_height(root->left);
		right_height = post_order_get_height(root->right);
		max_height = (left_height > right_height) ? left_height : right_height;
		return max_height + 1;
	}
	else return 0;//空树深度为0
}
```
###### 二元运算表达式树及其遍历
![二元运算表达式树及其遍历](https://img-blog.csdnimg.cn/20210521175151733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二元运算表达式树及其遍历"){:width=150px height=150px}
三种遍历可以得到三种不同的访问结果：
- [先序遍历](#先序遍历)得到前缀表达式：`++a*bc*+*defg`
- [中序遍历](#中序遍历)得到中缀表达式：`a+b*c+d*e+f*g`
- [后序遍历](#后序遍历)得到后缀表达式：`abc*+de*f+g*+`

其中，中缀表达式会受到运算符优先级的影响：可能出现`(a+b)*c`写成`a+b*c`的情况。
解决方法：输出左子树的时候，先输出个左括号，左子树结束的时候再加个右括号
###### 由两种遍历序列确定二叉树
当给定的两种遍历中有一种是**中序遍历**就可以确定**唯一**二叉树。
最简单的例子，先序：ab，后序：ba，当b是a的左或右儿子时都可以；先序是`根 左 右`，后序是`左 右 根`，无法区分`左 右`的关系。
***
先序和中序遍历序列来确定一棵二叉树：
1. 根据先序遍历序列第一个结点确定根结点；
2. 根据根结点在中序遍历序列中分割出左右两个子序列；
3. 对左子树和右子树分别递归使用相同的方法继续分解。

![先序与中序遍历](https://img-blog.csdnimg.cn/20210521180727894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "先序与中序遍历"){:width=150px height=150px}
例：先序序列`a b c d e f g h i j`，中序序列`c b e d a h g i j f`
- 从先序序列可知第一个结点`a`为根节点，则中序序列`a`结点前面的结点`c b e d`均为左子树的中序序列，中序序列`a`结点后面的结点`h g i j f`均为右子树的中序序列。
![由两种遍历序列确定二叉树1](https://img-blog.csdnimg.cn/2021052118202191.png#pic_center "由两种遍历序列确定二叉树1"){:width=100px height=100px}
- 再去先序序列中寻找左子树中序序列`c b e d`对应的这4个结点的先序序列（a后面取4个节点）`b c d e`，得`b`为左子树的根节点。
![由两种遍历序列确定二叉树2](https://img-blog.csdnimg.cn/20210521182149142.png#pic_center "由两种遍历序列确定二叉树2"){:width=150px height=150px}
- 然后去先序序列中寻找右子树中序序列`h g i j f`对应的这5个结点的先序序列`f g h i j`，得`f`为右子树的根节点。
依次类推，可求出二叉树为：
![由两种遍历序列确定二叉树3](https://img-blog.csdnimg.cn/20210521182613949.png#pic_center "由两种遍历序列确定二叉树3"){:width=150px height=150px}
### 二叉搜索树
二叉搜索树(Binary Search Tree,BST)又称二叉查找树或二叉排序树。一棵二叉搜索树是以二叉树来组织的，可以使用一个链表数据结构来表示，其中每一个结点包括数据域和指针域（两个指针分别指向左子节点和右子节点）。
它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。
判断是不是二叉搜索树--二叉搜索树可以为空，如果不为空，满足以下性质：
- 非空左子树的所有键值小于其根结点的键值；
- 非空右子树的所有键值大于其根结点的键值；
- 左、右子树都是二叉搜索树。
![二叉搜索树的判定](https://img-blog.csdnimg.cn/20210522214503958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉搜索树的判定"){:width=150px height=150px}
##### 查找
###### 查找指定元素
- 查找从根结点开始，如果树为空，返回NULL；
- 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：
  1. 若X小于根结点键值，只需在左子树中继续搜索；
  2. 如果X大于根结点的键值，在右子树中进行继续搜索；
  3. 若两者比较结果是相等，搜索完成，返回指向此结点的指针。
```
Position Find(ElementType X, BinTree BST)
{
    if(!BST) 
        return NULL;  //查找失败
    if(X > BST->Data)
        return Find(X, BST-> Right);  //在右子树中继续查找（使用“尾递归”）
    else if(X < BST->Data)
        return Find(X, BST->Left);  //在左子树中继续查找
    else  // X == BST->Data 
        return BST;  //查找成功，返回找到结点的地址
}
```
由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数：
```
Position IterFind(ElementType, BinTree BST)
{
    while(BST) {
        if(X >BST->Data)
            BST = BST->Right; //向右子树中移动，继续查找
        else if(X < BST->Data )
            BST = BST->Left;  //向左子树中移动，继续查找
        else  // X==BST->Data
            return BST;  //查找成功，返回结点的找到结点的地址
    }
    return NULL;  //查找失败
}
```
###### 查找最大和最小元素
最大元素一定是在树的最右分枝的端结点上；最小元素一定是在树的最左分枝的端结点上。
![查找最大和最小元素](https://img-blog.csdnimg.cn/20210522221525423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "查找最大和最小元素"){:width=150px height=150px}
```
Position FindMin(BinTree BST) //查找最小元素的递归函数
{
    if(!BST) 
        return NULL;  //空的二叉搜索树，返回NULL
    else if(!BST->Left) //BST没有左节点，则它是最左叶结点
        return BST;  //找到最左叶结点并返回
    else
        return FindMin(BST->Left);  //沿左分支继续查找
}        
Position FindMax(BinTree BST) //查找最大元素的迭代函数
{
    if(BST){
        while(BST->Right) 
            BST = BST-> Right;  //沿右分支继续查找，直到最右叶结点
    }
    return BST;
}
```
##### 插入
关键是要找到元素应该插入的位置，可以采用与查找类似的方法。
注意这里的插入都是插到叶节点下
![二叉搜索树插入操作](https://img-blog.csdnimg.cn/20210522222314952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉搜索树插入操作"){:width=150px height=150px}
```
BinTree Insert(ElementType X, BinTree BST)
{
    if(!BST){  //BST为空，说明已找到插入的位置--在BST处创建一个新节点（插入的节点）
        BST = malloc(sizeof (struct TreeNode));
        BST->Data = X;
        BST->Left = BST->Right = NULL;
    }
    else  //开始找要插入元素的位置
        if(X < BST->Data)
            BST->Left = Insert(X, BST->Left);  //递归插入左子树
        else if(X > BST->Data)
            BST->Right = Insert(X, BST->Right);  //递归插入右子树
        // else X已经存在, 什么都不做
    return BST; //执行一次函数，查找就向下一层推进一次。返回值表示查找到了哪个节点
}
```
难点：`BST->Left = Insert(X, BST->Left);`一定要用`BST->Left`接收返回值。
最简单的理由：最后一次插入新节点肯定是`BST->Left/right = 新节点`，要不新节点没有联系；
也不用担心不插入新节点时更改`BST->Left/right`值的问题，因为`Insert(X, BST->Left)`如果不插新节点返回的就是`BST->Left`。
[AVL树的根](#avl树的根)
##### 删除
二叉搜索树的删除要考虑以下三种情况：
1. 要删除的是叶结点：直接删除，并再修改其父结点指针，置为NULL
2. 要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点。
3. 要删除的结点有左、右两棵子树：用另一结点(右子树的最小元素或者左子树的最大元素)的数据替代被删除结点的数据，即
![二叉搜索树删除操作1](https://img-blog.csdnimg.cn/20210523125731205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二叉搜索树删除操作1"){:width=150px height=150px}或
![二叉搜索树删除操作2](https://img-blog.csdnimg.cn/20210523130008969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二叉搜索树删除操作2"){:width=150px height=150px}
```
BinTree Delete(ElementType X, BinTree BST)
{
    Position Tmp;
    if(!BST) 
        cout << "要删除的元素未找到!" << endl;
    else if(X < BST->Data)
        BST->Left = Delete(X, BST->Left);  //左子树递归删除
    else if(X > BST->Data)
        BST->Right = Delete(X, BST->Right);  //右子树递归删除
    else  //找到要删除的结点
        if(BST->Left && BST->Right)  //被删除结点有左右两个子结点
        {
            Tmp = FindMin(BST->Right);  //在右子树中找最小的元素填充删除结点
            BST->Data = Tmp->Data; //删除时用新数据覆盖旧数据就行，不需要把整个节点都删掉
            BST->Right = Delete(BST->Data, BST->Right);  //在删除结点的右子树中删除最小元素*/
        }
        else {  //被删除结点有一个或无子结点
            Tmp = BST;
            if(!BST->Left)  //有右孩子或无子结点
                BST = BST->Right; //BST继承它的右节点
            else if(!BST->Right )  //有左孩子或无子结点
                BST = BST->Left; //BST继承它的左节点
            free(Tmp); //释放BST节点
        }
    return BST;
}
```
### 平衡二叉树
平衡二叉树一般指平衡树。平衡树(Balance TreeBT)指的是，任意节点的子树的高度差都小于等于1。
平衡因子(Balance Factor,BF)：BF(T)=h~L~-h~R~，其中h~L~和h~R~分别为T的左、右子树的高度。
平衡二叉树(Balanced Binary Tree,AVL树)：空树或任一结点左、右子树高度差的绝对值不超过1的树，即`|BF(T)|<=1`。
平衡二叉树的目的是使得树的高度低一些，树越平衡，高度越低。
给定结点数为n的AVL树的最大高度为O(log~2~n)，log~2~n是结点为n的完全二叉树的高度。
```
typedef struct AVLNode *AVLTree;
struct AVLNode {
	int data;     // 存值 
	AVLTree left;  // 左子树 
	AVLTree right;  // 右子树 
	int height;  // 树高 
};
```
##### 平衡二叉树的调整
以下介绍的例子中约定：节点上的数字代表BF(T)=h~L~-h~R~，当该节点的|BF(T)|>1，称该节点为不平衡的**发现者**，导致树不平衡的那个新增节点称为**麻烦节点**
###### RR旋转
假设有下图左边所示的平衡二叉树，当在其右子树的右边插入元素Nov时二叉树变为如下图中间所示的情况，由于根结点Mar的平衡因子变为-2，所以二叉树不平衡了，需进行调整。调整的关键是使得元素Mar、May、Nov处于平衡状态，采用RR旋转，得到下图右边所示的平衡二叉树。
![RR旋转例](https://img-blog.csdnimg.cn/20210523165740336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RR旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是Mar，“**麻烦结点**”Nov在发现者**右**子树的**右**边，因而叫RR插入，需要RR旋转（右单旋）。
基本思路是把B的左子树腾出来挂到A的右子树上，再将A挂在B的左子树上，返回B作为当前子树的根，如图：
![RR旋转](https://img-blog.csdnimg.cn/20210523193647282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RR旋转"){:width=150px height=150px}
```
AVLTree RRRotation(AVLTree A)
{
    // 此时根节点是A
	AVLTree B = A->right;   // B为A的右子树  
	A->right = B->left;    // B的左子树挂在A的右子树上 
	B->left = A;   //  A挂在B的左子树上 
	return B;  // 此时B为根结点   
}
```
[LR旋转](#lr旋转)
[RL旋转](#rl旋转)
RR旋转的结果是：根节点的右子节点成为新的根节点，旧根节点成为新根节点的左子节点
###### LL旋转
设有下图左边所示的平衡二叉树，当在其左子树的左边插入元素Apr时二叉树变为如下图中间所示的情况，由于左孩子结点Mar的平衡因子变为2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素Mar、Aug、Apr处于平衡状态，采用LL旋转，得到下图右边所示的平衡二叉树。
![LL旋转例](https://img-blog.csdnimg.cn/20210523165405872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LL旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是Mar，“**麻烦结点**”Apr在发现者**左**子树的**左**边，因而叫LL插入，需要LL旋转（左单旋）。
基本思路是把B的右子树腾出来挂上A的左子树，再将A挂在B的右子树上，返回B作为当前子树的根，如下图所示。
![LL旋转](https://img-blog.csdnimg.cn/20210523192943479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LL旋转"){:width=150px height=150px}
```
AVLTree LLRotation(AVLTree A)
{
	// 此时根节点是A 
	AVLTree B = A->left;  // B为A的左子树  
	A->left = B->right;   // B的右子树挂在A的左子树上 
	B->right = A;     //  A挂在B的右子树上 
	return B;  // 此时B为根结点 
}
```
[LR旋转](#lr旋转)
[RL旋转](#rl旋转)
LL旋转的结果是：根节点的左子节点成为新的根节点，旧根节点成为新根节点的右子节点
###### LR旋转
假设有下图左边所示的平衡二叉树，当在其左子树的右边插入元素Jan时二叉树变为如下图中间所示的情况，由于根结点May的平衡因子变为2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素May、Aug、Mar处于平衡状态，采用LR旋转，得到下图右边所示的平衡二叉树。
![LR旋转例](https://img-blog.csdnimg.cn/20210523164920245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LR旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是May，“**麻烦结点**”Jan在左子树的右边，因而叫LR插入，需要LR旋转。
基本思路是先将B作为根结点进行[RR旋转](#rr旋转)（将C的左子树腾出来挂到B的右子树上，再将B挂在C的左子树上），再将A作为根结点进行[LL旋转](#ll旋转)（把C的右子树腾出来挂到A的左子树上，再将A挂在C的右子树上），即先进行RR旋转再进行LL旋转，如下图所示。
![LR旋转](https://img-blog.csdnimg.cn/20210523192652494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LR旋转"){:width=150px height=150px}
```
AVLTree LRRotation(AVLTree A)
{
	A->left = RRRotation(A->left); // 先RR旋转
	return LLRotation(A); // 再LL旋转 
}
```
###### RL旋转
假设有下图左边所示的平衡二叉树，当在其左子树结点的右边孩子节点的左边插入元素Feb时二叉树变为如下图中间所示的情况，由于左孩子结点Aug的平衡因子变为-2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素Aug、Jan、Dec处于平衡状态，采用RL旋转，得到下图右边所示的平衡二叉树。
![RL旋转例](https://img-blog.csdnimg.cn/20210523165304373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RL旋转例"){:width=150px height=150px}
RL旋转的基本思路是先将B作为根结点进行[LL旋转](#ll旋转)（将C的右子树腾出来挂到B的左子树上，再将B挂在C的右子树上），再将A作为根结点进行[RR旋转](#rr旋转)（将C的左子树腾出来挂到A的右子树上，再将A挂在C的左子树上），即先进行LL旋转再进行RR旋转，如下图所示。
![RL旋转](https://img-blog.csdnimg.cn/20210523193159779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RL旋转"){:width=150px height=150px}
```
AVLTree RLRotation(AVLTree A)
{
	A->right = LLRotation(A->right); // 先LL旋转
	return RRRotation(A); // 再RR旋转 
}
```
##### AVL树的根
AVL树是一种自平衡二叉搜索树，在AVL树中任何结点的两个子树的高度最多相差1。假设由于在二叉搜索树上插入结点而失去平衡，则需要进行调整以恢复此属性，如下图所示
![AVL树的根](https://img-blog.csdnimg.cn/20210523202827112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "AVL树的根"){:width=300px height=300px}
预先定义代码：
```
int Max(int a, int b) // 返回最大值 
{
	return a > b ? a : b;
}
int getHeight(AVLTree A) // 返回树高，若该节点为叶节点则返回0，空树返回-1（与叶节点做区分）
{
	return A == NULL ? -1 : A->height;
}
//以及4种旋转
```
求根节点为T的AVL树插入新节点x后的新根节点：思路类似[二叉搜索树的插入](#插入)，要先根据数据大小判断插入到左/右子树，再递归插入；同时为确保平衡，当不平衡时要根据插入的位置进行旋转；最后不要忘了更新节点的高度
```
AVLTree Insert(AVLTree T, int x)
{
	if (!T)  // 如果该结点为空，初始化结点
	{
		T = (AVLTree)malloc(sizeof(struct AVLNode));
		T->data = x;
		T->left = NULL;
		T->right = NULL;
		T->height = 0;
	}
	else   // 否则不为空
	{
		if (x < T->data)  // 左子树
		{
			T->left = Insert(T->left, x);
			if (getHeight(T->left) - getHeight(T->right) == 2)   //如果左子树和右子树高度差为2（因为插入到左子树，肯定左子树树高>右子树）
			{
				if (x < T->left->data)  //x应插入到根节点左子树的左侧--LL旋转 
					T = LLRotation(T); //旋转后要更新根节点
				else if (x > T->left->data)  //x应插入到根节点左子树的右侧--LR旋转
					T = LRRotation(T);
			}
		}
		else if (x > T->data)   // 右子树
		{
			T->right = Insert(T->right, x);
			if (getHeight(T->right) - getHeight(T->left) == 2)
			{
				if (x < T->right->data)  //x应插入到根节点右子树的左侧--RL旋转 
					T = RLRotation(T);
				else if (x > T->right->data)  //x应插入到根节点右子树的右侧--RR旋转
					T = RRRotation(T);
			}
		}
	}
	//更新树高 
	T->height = Max(getHeight(T->left), getHeight(T->right)) + 1;
	return T;
}
```
### 堆
堆(Heap)是计算机科学中一类特殊的数据结构的统称，通常是一个可以被看做一棵完全二叉树的数组对象。
堆总是满足下列**性质**：
- 堆中某个结点的值总是不大于或不小于其父结点的值；
- 堆总是一棵**完全二叉树**。

堆是**非线性数据结构**，相当于一维数组，有两个直接后继。
***
优先队列(Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的**优先权(关键字)大小**，而不是元素进入队列的先后顺序。
优先队列的完全二叉树表示：![优先队列的完全二叉树表示](https://img-blog.csdnimg.cn/20210528103433896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "优先队列的完全二叉树表示"){:width=150px height=150px}
***
堆的两个**特性**：
- **结构性**：堆是用数组表示的完全二叉树；
- **有序性**：任一结点的关键字是其子树所有结点的最大值(或最小值)。
根节点为最大值的称为“最大堆(MaxHeap)”，也称“大顶堆”：
![最大堆](https://img-blog.csdnimg.cn/20210528110304418.png#pic_center "最大堆"){:width=100px height=100px}
根节点为小值的称为“最小堆(MinHeap)”，也称“小顶堆”：
![最小堆](https://img-blog.csdnimg.cn/20210528110320280.png#pic_center "最小堆"){:width=100px height=100px}
##### 最大堆操作
###### 初始化
最大堆的数据结构定义:
```
typedef struct HeapStruct* MaxHeap;
struct HeapStruct {
    ElementType *Elements;  //存储堆元素的数组
    int Size;  //堆的当前元素个数
    int Capacity;  //堆的最大容量
};
```
初始化最大堆：因为堆是完全二叉树，所以堆数组从索引为1的位置开始存储元素，所以申内存时要Maxsize+1；堆数组的第一个元素不存储有效数据，于是用来存放最大值
```
MaxHeap Create(int Maxsize)  //创建容量为MaxSize的空的最大堆
{
    MaxHeap H = malloc(sizeof(struct Heapstruct));
    H->Elements = malloc((Maxsize+1) * sizeof(ElementType));
    H->Size = 0 ;
    H->Capacity = Maxsize;
    H->Elements [0] = MaxData;  //定义“哨兵”MaxData为大于堆中所有可能元素的值，便于以后更快操作
    return H;
}
```
基础操作：
```
// 判断是否已经满 
bool IsFull(MaxHeap H) 
{
	return (H->Size == H->Capacity);
}
// 判断是否为空
bool IsEmpty(MaxHeap H) 
{
	return !H->Size;
}
```
###### 插入
如图的5个元素：
![最大堆插入1](https://img-blog.csdnimg.cn/20210528154907578.png#pic_center "最大堆插入1"){:width=100px height=100px}
现要向其中插入1个元素，最简单的想法就是把它放入堆数组的最后1个位置，即上图`[6]`的地方；
插入后需判断符不符合堆的性质：只要插入的那个元素<它的父节点就满足；如果不满足，就交换它与它的父节点，交换后，还要再比较它与它的新父节点。
![最大堆插入2](https://img-blog.csdnimg.cn/20210528114246197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "最大堆插入2"){:width=300px height=300px}
核心算法：将新增结点插入到从其父结点到根结点的有序序列中。
为提高速度，当不满足堆性质时，我们不使用交换的方式，而是让新数的父节点覆盖它的位置，直到新数<=它的父节点，循环结束，把新数写到空缺的那个位置上
```
void Insert(MaxHeap H, ElementType item) //插入
{
    int i;
    if (IsFull(H)) 
    {
        cout << "最大堆已满" << endl;
        return;
    }
    i = ++H->Size; //i表示新数要插入到堆数组的位置（原来的size+1的位置）
	//同时堆的size也要增大1、
	//新数位置是H->Elements[i]，它的父节点是H->Elements[i/2]
    for (; H->Elements[i/2]<item; i/=2)  //i每/2，就是向上推进一层
	//循环持续条件：新数>它的父节点
        H->Elements[i] = H->Elements[i/2]; //覆盖新数的位置
	//循环结束时，i/2是它的父节点，i就是它应该在的位置
    H->Elements[i]= item;  //item插入
}
```
不用担心死循环的问题，因为i肯定会有==1的时候，`1/2`就是0，`Elements[0]`是最大值，item肯定<最大值
###### 删除
删除堆的根节点（最大的那个元素），并将删除的节点值返回。
思路：在根节点删除后，将堆数组的最后1个元素移到根节点；为确保堆的有序性，找出这个元素较大的子节点，若比它大，就将它们交换；重复上述过程，直到这个元素较大的子节点也小于它。
例： 在下图所示的树中删除元素58的情况如下图所示
![最大堆删除](https://img-blog.csdnimg.cn/20210528154717300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "最大堆删除"){:width=250px height=100px}
```
ElementType DeleteMax(MaxHeap H) //删除
{
    int Parent,Child;
    ElementType MaxItem, temp;
    if (IsEmpty(H)) 
    {
        cout << "最大堆已为空" << endl;
        return ;
    }
    MaxItem = H->Elements[1];  //保存原根结点最大值
    temp = H->Elements [H->size--];  //拿到完全二叉树最后一个元素，同时堆的size-1
	//接下来需要找temp的位置，同时完成新根节点的赋值
	//使用Parent表示temp应该在的位置（初始为1即根节点），按照上面的思路，应该让temp与它的子节点Child比较
    for(Parent=1; Parent*2<=H->size; Parent=Child)   //大结束条件：Parent没有左儿子(Parent*2<=H->size)
    {
        Child = Parent * 2; //Parent的右儿子就是child+1
        if((Child!=H->Size)&&(H->Elements[Child]<H->Elements[Child+1]))  //Child!=H->Size表示Child不为当前最后一个结点，即Parent有右孩子结点
            Child++;  //让Child指向左右子结点的较大者
        //给temp找个合适的位置 
        if(temp>=H->Elements[Child])   //如果temp较大的子节点也小于它，说明temp位置已经合适
            break ;
        else  //位置不合适时
        H->Elements[Parent]=H->Elements[Child]; //让较大的子节点移动到它的位置
		//同时Parent=Child移动到下一层进行判断
    }
    H->Elements [Parent] = temp;  //在合适的位置把temp放进去
    return MaxItem;
}
```
###### 建立
建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。
- 第一种方法：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，时间复杂度`O(NlogN)`，因为插入一个元素的时间复杂度为`O(logN)`
- 更好的方法：
	1. 将N个元素按输入顺序存入，先满足**完全二叉树的结构特性**；
	2. 调整各结点位置，以满足**最大堆的有序特性**。
   
	这种方法的时间复杂度为`O(n)`

任何调整各结点位置使其成堆：
- 从堆的删除出发，删除最大值实际就是在根节点的左右子树都是堆的基础上，指定根节点为某个数，经过调整使它们整体重新成堆的过程；
- 于是可以从倒数第一个有子节点的父节点开始，因为它的左右子树至多都只有1个元素，所以满足堆删除的条件，因此可以用上述思路把这个父子结构调成小堆，依此类推，从下至上，把所有父节点都调成堆

```
// 排序，类似堆的"删除操作" 
void sort(MaxHeap H, int i)  //将父节点索引为i的子堆调整为最大堆
{
	int Child, Parent;
	int temp = H->data[i];  //设根节点数为H->data[i]，即传入的父节点
	for (Parent = i; Parent * 2 <= H->size; Parent = Child) //传入根节点在总堆数组的初始位置为i，照应上面删除代码中Parent=1
	{ //循环体内代码同前
		Child = 2 * Parent;
		if ((Child != H->size) && (H->data[Child] < H->data[Child + 1]))
			Child++; 
		if (temp >= H->data[Child])
			break;
		else
			H->data[Parent] = H->data[Child];
	}
	H->data[Parent] = temp;
}
// 最大堆的建立(调整H->Data[]中的元素，使满足最大堆的有序性)
void BuildHeap(MaxHeap H) 
{
	for (int i = H->size / 2; i > 0; i--)  //从最后一个结点的父节点开始，到根结点1
	{
		sort(H, i); //以每个有孩子结点的结点作为根结点，对其子树进行堆排序 
	}
}
//主函数调用
int main() 
{
	MaxHeap H;
	H = Create();
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> H->data[++H->size]; //注意要初始化size
	BuildHeap(H);
	return 0;
}
```
**注意：堆的操作实际上都是通过改变堆数组来实现**
### 哈夫曼树和哈夫曼编码