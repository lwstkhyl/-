<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [树](#树)
    - [定义](#定义)
    - [表示](#表示)
- [二叉树](#二叉树)
    - [定义](#定义-1)
    - [性质](#性质)
    - [存储](#存储)
      - [顺序存储结构](#顺序存储结构)
      - [链表存储结构](#链表存储结构)
    - [递归遍历](#递归遍历)
      - [先序遍历](#先序遍历)
      - [中序遍历](#中序遍历)
      - [后序遍历](#后序遍历)
    - [非递归遍历](#非递归遍历)
      - [中序遍历](#中序遍历-1)
      - [先序遍历](#先序遍历-1)
      - [后序遍历](#后序遍历-1)
      - [层序遍历](#层序遍历)
    - [遍历的应用](#遍历的应用)
      - [输出叶子节点](#输出叶子节点)
      - [求树高度](#求树高度)
      - [二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
      - [由两种遍历序列确定二叉树](#由两种遍历序列确定二叉树)
- [二叉搜索树](#二叉搜索树)
    - [查找](#查找)
      - [查找指定元素](#查找指定元素)
      - [查找最大和最小元素](#查找最大和最小元素)
    - [插入](#插入)
    - [删除](#删除)
- [平衡二叉树](#平衡二叉树)
    - [平衡二叉树的调整](#平衡二叉树的调整)
      - [RR旋转](#rr旋转)
      - [LL旋转](#ll旋转)
      - [LR旋转](#lr旋转)
      - [RL旋转](#rl旋转)
    - [AVL树的根](#avl树的根)
- [堆](#堆)
    - [最大堆操作](#最大堆操作)
      - [初始化](#初始化)
      - [插入](#插入-1)
      - [删除](#删除-1)
      - [建立](#建立)
- [哈夫曼树和哈夫曼编码](#哈夫曼树和哈夫曼编码)
    - [哈夫曼树](#哈夫曼树)
      - [权值](#权值)
      - [哈夫曼树的定义](#哈夫曼树的定义)
      - [哈夫曼树的构造](#哈夫曼树的构造)
      - [哈夫曼树的特点](#哈夫曼树的特点)
    - [哈夫曼编码](#哈夫曼编码)
- [集合](#集合)
    - [集合的表示](#集合的表示)
    - [集合运算](#集合运算)
      - [查找某个元素所在的集合](#查找某个元素所在的集合)
      - [合并集合](#合并集合)
      - [合并集合的改进](#合并集合的改进)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 树
##### 定义
树(Tree) ：n(n≥0)个结点构成的有限集合。当n=0时，称为空树。
对于任一棵非空树(n>0)，它具备以下性质：
- 树中有一个称为“根(Root)”的特殊结点，用r表示；
- 其余结点可分为m(m>0)个互不相交的有限集T1、T2、...Tm，其中每个集合本身又是一棵树，称为原来树的“子树”(subTree)
![树的定义](https://img-blog.csdnimg.cn/20210521103757235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "树的定义"){:width=150px height=150px}
***
如何判断一个结构是不是树：
- 子树是不相交的；
- 除了根结点外，每个结点有且仅有一个父结点；
- 一棵N个结点的树有N-1条边。

一些非树的例子：
![非树的例子](https://img-blog.csdnimg.cn/20210521104042831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "非树的例子"){:width=150px height=150px}
***
树的一些相关定义：
- 结点的度(Degree)：结点的子树个数
- 树的度：树的所有结点中最大的度数
- 叶结点(leaf)：度为0的结点，即树最底层的节点，没有子树
- 父结点(parent)：有子树的结点是其子树的根节点的父结点
- 子结点（孩子结点）(child)：若A结点是B结点的父节点，则称B结点为A结点的子结点
- 兄弟结点(sibling)：具有同一父结点的各结点彼此是兄弟结点
- 路径和路径长度：从结点n1到nk的路径为一个结点序列n~1~,n~2~,...,n~k~（其中n~i~是n~i+1~的父结点）；路径所包含边的个数为路径的长度
- 祖先结点(ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
- 子孙结点(descendant)：某一结点的子树中的所有结点是这个结点的子孙
- 结点的层次(level)：规定根结点在1层，其他任一结点的层数是其父结点的层数加1
- 树的深度(depth)：树中所有结点中的最大层次
##### 表示
1. 使用链表：
    i. 一个结点有几个子节点，它就有几个指针，但这种结构中每个结点的指针域都不同
    ![树的链表表示法](https://img-blog.csdnimg.cn/20210521105620946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "树的链表表示法"){:width=150px height=150px}
    ii. 把所有结点的指针个数都设为同一值，即子树的最大个数。子树数量少的结点中把没用的指针设为null，但这样会多使用指针，造成空间上的浪费
2. 儿子-兄弟表示法：每个结点都有两个指针，一个指针指向第一个儿子FirstChild，另一个指针指向下一个兄弟NextSibling。
    好处：树中所有结点的结构是统一的，都为两个指针域；如果树有n个结点，则树就有2n个指针域，树有n-1条边，所有就有n-1个指针域是空的，造成空间上的浪费也不大。
    ![树的儿子-兄弟表示法](https://img-blog.csdnimg.cn/20210521110202824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_14,color_FFFFFF,t_70#pic_center "树的儿子-兄弟表示法"){:width=150px height=150px}

将上述所示的儿子-兄弟表示法表示的树，顺时针旋转45°，一个指针指向左子树Left（左儿子），另一个指针指向右子树Right（右儿子）。
![树的儿子-兄弟表示法2](https://img-blog.csdnimg.cn/20210521111155275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "树的儿子-兄弟表示法2"){:width=150px height=150px}
### 二叉树
##### 定义
二叉树：一个有穷的结点集合，这个集合可以为空；若不为空，则它是由根节点和被称为左子树Tl和右子树Tr的两个不相交的二叉树组成，是有序树。
共有5种形态：空、只有一个节点、左子树为空、右子树为空、左右子树都有（都不为空）。
**特点**是每个结点最多只能有两棵子树，且有左右之分。
***
特殊二叉树：
1. 斜二叉树：只有左儿子或者只有右儿子，就相当于一个链表
![斜二叉树](https://img-blog.csdnimg.cn/20210521151718817.png#pic_center "斜二叉树"){:width=150px height=150px}
2. 完美二叉树（满二叉树）：每个节点都有两个儿子（除了最底层的叶节点），且层数n与该层内结点数N满足：`N=2^(n-1)` 即都是`1->2->4->8.....`这种
![完美二叉树](https://img-blog.csdnimg.cn/20210521151805389.png#pic_center "完美二叉树"){:width=150px height=150px}
3. 完全二叉树：有n个节点的二叉树，对树中节点按从上至下、从左至右的顺序编号，编号为i的节点与满二叉树中编号为i的节点在二叉树中的位置相同，即它的倒数第二层往上与完美二叉树相同，最后一层中允许缺最右面开始往左的多个节点，但最左面与完美二叉树对齐
![完全二叉树](https://img-blog.csdnimg.cn/20210521154402495.png#pic_center "完全二叉树"){:width=150px height=150px}
##### 性质
- 一个二叉树第i层的最大结点数为2^i-1^,(i>=1)
- 深度为k kk的二叉树有最大结点总数为2^k^-1,(k>1)
- 对任何非空二叉树，若n~0~表示叶节点个数，n~2~是度为2的非叶节点个数，则n~0~=n~2~+1。
因为`总边数`=`总节点数(n0+n1+n2)`-1,其中n0的节点往下没有边,n1的节点有1条,n2的节点有2条
即n0+n1+n2-1=0\*n0+1\*n1+2\*n2，可得上述关系
##### 存储
###### 顺序存储结构
由于二叉树的分支少（只有两个）所以可以用数组实现，最适合的树就是完全二叉树，按从上至下、从左至右的顺序存储（1->9）
![二叉树顺序存储结构1](https://img-blog.csdnimg.cn/20210521160956161.png#pic_center "二叉树顺序存储结构1"){:width=150px height=150px}
n个结点的完全二叉树的**结点父子关系**：
- 对任一序号为`i`的非根节点，其父结点的序号是`i/2`
- `i`节点的左儿子序号是`2i`，右儿子的序号是`2i+1`；`2i<=n`时`i`有左儿子，`2i+1<=n`时有右儿子（n为节点总数）
对于一般的二叉树，也可以用数组实现，但需要对其进行补充，使其称为完全二叉树，造成空间浪费：
![二叉树顺序存储结构2](https://img-blog.csdnimg.cn/20210521162010460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉树顺序存储结构2"){:width=200px height=200px}
###### 链表存储结构
每个节点有三个元素，一个是数据，另外两个是左指针和右指针
```
struct tree_node
{
	int data;
	struct tree_node* left;
	struct tree_node* right;
};
```
如下图左边所示的二叉树，链表存储结构如右边所示：
![二叉树链表存储结构](https://img-blog.csdnimg.cn/20210521162601674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉树链表存储结构"){:width=200px height=200px}
##### 递归遍历
###### 先序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
访问根节点->遍历其左子树->遍历其右子树
```
void pre_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		printf("%d", root->data);
		pre_order_traversal(root->left);
		pre_order_traversal(root->right);
	}
}
```
![先序遍历](https://img-blog.csdnimg.cn/20210521163649704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "先序遍历"){:width=150px height=150px}
上图所示的二叉树先序遍历顺序：`A B D F E C G H I`。
###### 中序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
遍历其左子树->访问根节点->遍历其右子树
```
void in_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		in_order_traversal(root->left);
		printf("%d", root->data);
		in_order_traversal(root->right);
	}
}
```
![中序遍历](https://img-blog.csdnimg.cn/20210521164551359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "中序遍历"){:width=150px height=150px}
上图所示的二叉树中序遍历顺序：`D B E F A G H C l`。
###### 后序遍历
[二元运算表达式树及其遍历](#二元运算表达式树及其遍历)
遍历其左子树->遍历其右子树->访问根节点
```
void post_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		post_order_traversal(root->left);
		post_order_traversal(root->right);
		printf("%d", root->data);
	}	
}
```
![后序遍历](https://img-blog.csdnimg.cn/20210521165033198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_12,color_FFFFFF,t_70#pic_center "后序遍历"){:width=150px height=150px}
上图所示的二叉树后序遍历顺序：`D E F B H G I C A`。
***
对于递归的先中后序遍历，它们过程中经过节点的路径一样，只是访问(printf)各节点的时机不同。
##### 非递归遍历
非递归算法实现的**基本思路：使用堆栈**。
###### 中序遍历
遇到一个节点，就把它压入栈中，并遍历它的左子树，当左子树遍历结束后，从栈顶抛出这个节点并printf它，然后按其右指针再去中序遍历该节点的右子树
```
void de_in_order_traversal(struct tree_node* root)
{
	struct tree_node* p = root;//辅助指针变量
	stack<tree_node*> s;
	while (p != NULL || !s.empty()) //当p为空且栈也空时退出循环
	{
		while (p != NULL)//遍历左子树，一直向左并将沿途节点压入栈中
		{
			s.push(p);
			p = p->left;  //让p指向p节点的左儿子
		}
		if (!s.empty())
		{
			printf("%5d", s.top()->data);//打印栈顶节点
			p = s.top();
			s.pop();  //抛出该节点
			p = p->right;//p指向原栈顶节点的右节点（转向右子树）
		}
	}
}
```
###### 先序遍历
```
void de_pre_order_traversal(struct tree_node* root)
{
	struct tree_node* p = root;//辅助指针变量
	stack<tree_node*> s;
	while (p != NULL || !s.empty()) //当p为空且栈也空时退出循环
	{
		while (p != NULL)
		{
			s.push(p); //压栈，第一次遇到该结点 
			printf("%5d", s.top()->data);
			p = p->left; //遍历左子树 
		}
		if (!s.empty())
		{
			p = s.top();
			s.pop(); //出栈，第二次遇到该结点 
			p = p->right; //访问右结点 
		}
	}
}
```
###### 后序遍历
```
void PostOrderTraversal(BinTree BT)
{
	BinTree T = BT;
	Stack S = CreateStack();  //创建并初始化堆栈S
	vector<BinTree> v;   //创建存储树结点的动态数组
	Push(S,T);
	while(!IsEmpty(S)){  //当树不为空或堆栈不空 
		T = Pop(S); //T是S中栈顶元素
		v.push_back(T);  //出栈元素进数组
		if(T->Left)
			Push(S,T->Left);
		if(T->Right)
			Push(S,T->Right);
	}
	reverse(v.begin(),v.end());  //逆转 
	for(int i=0;i<v.size();i++)  //输出数组元素
		cout << v[i]->Data << endl;
} 
```
###### 层序遍历
利用**队列**：先根结点入队，然后循环执行--
1. 从队列中取出一个元素（首元素）；                
2. 访问(printf)该元素所指结点；
3. 若该元素所指结点的左、右子结点非空，则将其左、右子结点的指针顺序入队。
```
void level_order_travelsal(struct tree_node* root)
{
	queue<struct tree_node*> q;
	struct tree_node* p; //辅助指针变量
	if (root == NULL)
		return;
	q.push(root); //根结点入队
	while (!q.empty())
	{
		p = q.front(); //从队列中取出第一个元素
		printf("%d", p->data); //访问该元素所指结点
		q.pop(); //删除刚刚取出的q.front()
        //若该元素所指结点的左、右子结点非空，则将其左、右子结点的指针顺序入队。
		if (p->left != NULL) q.push(p->left);
		if (p->right != NULL) q.push(p->right);
	}
}
```
[回到目录](#mulu)
##### 遍历的应用
###### 输出叶子节点
输出二叉树中的叶子节点（没有儿子的节点）：在二叉树遍历算法中的printf前添加条件，检测是否为叶子节点
```
void pre_order_traversal(struct tree_node* root)
{
	if (root != NULL)
	{
		if(root->left==NULL&&root->right==NULL)
			printf("%d", root->data);
		pre_order_traversal(root->left);
		pre_order_traversal(root->right);
	}
}
```
###### 求树高度
求二叉树的高度：用递归来做--一个二叉树的高度=max(左右两个子树的高度)+1
```
int post_order_get_height(struct tree_node* root)
{
	int left_height, right_height, max_height;
	if (root != NULL)
	{
		left_height = post_order_get_height(root->left);
		right_height = post_order_get_height(root->right);
		max_height = (left_height > right_height) ? left_height : right_height;
		return max_height + 1;
	}
	else return 0;//空树深度为0
}
```
###### 二元运算表达式树及其遍历
![二元运算表达式树及其遍历](https://img-blog.csdnimg.cn/20210521175151733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二元运算表达式树及其遍历"){:width=150px height=150px}
三种遍历可以得到三种不同的访问结果：
- [先序遍历](#先序遍历)得到前缀表达式：`++a*bc*+*defg`
- [中序遍历](#中序遍历)得到中缀表达式：`a+b*c+d*e+f*g`
- [后序遍历](#后序遍历)得到后缀表达式：`abc*+de*f+g*+`

其中，中缀表达式会受到运算符优先级的影响：可能出现`(a+b)*c`写成`a+b*c`的情况。
解决方法：输出左子树的时候，先输出个左括号，左子树结束的时候再加个右括号
###### 由两种遍历序列确定二叉树
当给定的两种遍历中有一种是**中序遍历**就可以确定**唯一**二叉树。
最简单的例子，先序：ab，后序：ba，当b是a的左或右儿子时都可以；先序是`根 左 右`，后序是`左 右 根`，无法区分`左 右`的关系。
***
先序和中序遍历序列来确定一棵二叉树：
1. 根据先序遍历序列第一个结点确定根结点；
2. 根据根结点在中序遍历序列中分割出左右两个子序列；
3. 对左子树和右子树分别递归使用相同的方法继续分解。

![先序与中序遍历](https://img-blog.csdnimg.cn/20210521180727894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "先序与中序遍历"){:width=150px height=150px}
例：先序序列`a b c d e f g h i j`，中序序列`c b e d a h g i j f`
- 从先序序列可知第一个结点`a`为根节点，则中序序列`a`结点前面的结点`c b e d`均为左子树的中序序列，中序序列`a`结点后面的结点`h g i j f`均为右子树的中序序列。
![由两种遍历序列确定二叉树1](https://img-blog.csdnimg.cn/2021052118202191.png#pic_center "由两种遍历序列确定二叉树1"){:width=100px height=100px}
- 再去先序序列中寻找左子树中序序列`c b e d`对应的这4个结点的先序序列（a后面取4个节点）`b c d e`，得`b`为左子树的根节点。
![由两种遍历序列确定二叉树2](https://img-blog.csdnimg.cn/20210521182149142.png#pic_center "由两种遍历序列确定二叉树2"){:width=150px height=150px}
- 然后去先序序列中寻找右子树中序序列`h g i j f`对应的这5个结点的先序序列`f g h i j`，得`f`为右子树的根节点。
依次类推，可求出二叉树为：
![由两种遍历序列确定二叉树3](https://img-blog.csdnimg.cn/20210521182613949.png#pic_center "由两种遍历序列确定二叉树3"){:width=150px height=150px}
### 二叉搜索树
二叉搜索树(Binary Search Tree,BST)又称二叉查找树或二叉排序树。一棵二叉搜索树是以二叉树来组织的，可以使用一个链表数据结构来表示，其中每一个结点包括数据域和指针域（两个指针分别指向左子节点和右子节点）。
它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。
判断是不是二叉搜索树--二叉搜索树可以为空，如果不为空，满足以下性质：
- 非空左子树的所有键值小于其根结点的键值；
- 非空右子树的所有键值大于其根结点的键值；
- 左、右子树都是二叉搜索树。
![二叉搜索树的判定](https://img-blog.csdnimg.cn/20210522214503958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉搜索树的判定"){:width=150px height=150px}
##### 查找
###### 查找指定元素
- 查找从根结点开始，如果树为空，返回NULL；
- 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：
  1. 若X小于根结点键值，只需在左子树中继续搜索；
  2. 如果X大于根结点的键值，在右子树中进行继续搜索；
  3. 若两者比较结果是相等，搜索完成，返回指向此结点的指针。
```
Position Find(ElementType X, BinTree BST)
{
    if(!BST) 
        return NULL;  //查找失败
    if(X > BST->Data)
        return Find(X, BST-> Right);  //在右子树中继续查找（使用“尾递归”）
    else if(X < BST->Data)
        return Find(X, BST->Left);  //在左子树中继续查找
    else  // X == BST->Data 
        return BST;  //查找成功，返回找到结点的地址
}
```
由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数：
```
Position IterFind(ElementType, BinTree BST)
{
    while(BST) {
        if(X >BST->Data)
            BST = BST->Right; //向右子树中移动，继续查找
        else if(X < BST->Data )
            BST = BST->Left;  //向左子树中移动，继续查找
        else  // X==BST->Data
            return BST;  //查找成功，返回结点的找到结点的地址
    }
    return NULL;  //查找失败
}
```
###### 查找最大和最小元素
最大元素一定是在树的最右分枝的端结点上；最小元素一定是在树的最左分枝的端结点上。
![查找最大和最小元素](https://img-blog.csdnimg.cn/20210522221525423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "查找最大和最小元素"){:width=150px height=150px}
```
Position FindMin(BinTree BST) //查找最小元素的递归函数
{
    if(!BST) 
        return NULL;  //空的二叉搜索树，返回NULL
    else if(!BST->Left) //BST没有左节点，则它是最左叶结点
        return BST;  //找到最左叶结点并返回
    else
        return FindMin(BST->Left);  //沿左分支继续查找
}        
Position FindMax(BinTree BST) //查找最大元素的迭代函数
{
    if(BST){
        while(BST->Right) 
            BST = BST-> Right;  //沿右分支继续查找，直到最右叶结点
    }
    return BST;
}
```
##### 插入
关键是要找到元素应该插入的位置，可以采用与查找类似的方法。
注意这里的插入都是插到叶节点下
![二叉搜索树插入操作](https://img-blog.csdnimg.cn/20210522222314952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉搜索树插入操作"){:width=150px height=150px}
```
BinTree Insert(ElementType X, BinTree BST)
{
    if(!BST){  //BST为空，说明已找到插入的位置--在BST处创建一个新节点（插入的节点）
        BST = malloc(sizeof (struct TreeNode));
        BST->Data = X;
        BST->Left = BST->Right = NULL;
    }
    else  //开始找要插入元素的位置
        if(X < BST->Data)
            BST->Left = Insert(X, BST->Left);  //递归插入左子树
        else if(X > BST->Data)
            BST->Right = Insert(X, BST->Right);  //递归插入右子树
        // else X已经存在, 什么都不做
    return BST; //执行一次函数，查找就向下一层推进一次。返回值表示查找到了哪个节点
}
```
难点：`BST->Left = Insert(X, BST->Left);`一定要用`BST->Left`接收返回值。
最简单的理由：最后一次插入新节点肯定是`BST->Left/right = 新节点`，要不新节点没有联系；
也不用担心不插入新节点时更改`BST->Left/right`值的问题，因为`Insert(X, BST->Left)`如果不插新节点返回的就是`BST->Left`。
[AVL树的根](#avl树的根)
##### 删除
二叉搜索树的删除要考虑以下三种情况：
1. 要删除的是叶结点：直接删除，并再修改其父结点指针，置为NULL
2. 要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点。
3. 要删除的结点有左、右两棵子树：用另一结点(右子树的最小元素或者左子树的最大元素)的数据替代被删除结点的数据，即
![二叉搜索树删除操作1](https://img-blog.csdnimg.cn/20210523125731205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二叉搜索树删除操作1"){:width=150px height=150px}或
![二叉搜索树删除操作2](https://img-blog.csdnimg.cn/20210523130008969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_15,color_FFFFFF,t_70#pic_center "二叉搜索树删除操作2"){:width=150px height=150px}
```
BinTree Delete(ElementType X, BinTree BST)
{
    Position Tmp;
    if(!BST) 
        cout << "要删除的元素未找到!" << endl;
    else if(X < BST->Data)
        BST->Left = Delete(X, BST->Left);  //左子树递归删除
    else if(X > BST->Data)
        BST->Right = Delete(X, BST->Right);  //右子树递归删除
    else  //找到要删除的结点
        if(BST->Left && BST->Right)  //被删除结点有左右两个子结点
        {
            Tmp = FindMin(BST->Right);  //在右子树中找最小的元素填充删除结点
            BST->Data = Tmp->Data; //删除时用新数据覆盖旧数据就行，不需要把整个节点都删掉
            BST->Right = Delete(BST->Data, BST->Right);  //在删除结点的右子树中删除最小元素*/
        }
        else {  //被删除结点有一个或无子结点
            Tmp = BST;
            if(!BST->Left)  //有右孩子或无子结点
                BST = BST->Right; //BST继承它的右节点
            else if(!BST->Right )  //有左孩子或无子结点
                BST = BST->Left; //BST继承它的左节点
            free(Tmp); //释放BST节点
        }
    return BST;
}
```
### 平衡二叉树
平衡二叉树一般指平衡树。平衡树(Balance TreeBT)指的是，任意节点的子树的高度差都小于等于1。
平衡因子(Balance Factor,BF)：BF(T)=h~L~-h~R~，其中h~L~和h~R~分别为T的左、右子树的高度。
平衡二叉树(Balanced Binary Tree,AVL树)：空树或任一结点左、右子树高度差的绝对值不超过1的树，即`|BF(T)|<=1`。
平衡二叉树的目的是使得树的高度低一些，树越平衡，高度越低。
给定结点数为n的AVL树的最大高度为O(log~2~n)，log~2~n是结点为n的完全二叉树的高度。
```
typedef struct AVLNode *AVLTree;
struct AVLNode {
	int data;     // 存值 
	AVLTree left;  // 左子树 
	AVLTree right;  // 右子树 
	int height;  // 树高 
};
```
##### 平衡二叉树的调整
以下介绍的例子中约定：节点上的数字代表BF(T)=h~L~-h~R~，当该节点的|BF(T)|>1，称该节点为不平衡的**发现者**，导致树不平衡的那个新增节点称为**麻烦节点**
###### RR旋转
假设有下图左边所示的平衡二叉树，当在其右子树的右边插入元素Nov时二叉树变为如下图中间所示的情况，由于根结点Mar的平衡因子变为-2，所以二叉树不平衡了，需进行调整。调整的关键是使得元素Mar、May、Nov处于平衡状态，采用RR旋转，得到下图右边所示的平衡二叉树。
![RR旋转例](https://img-blog.csdnimg.cn/20210523165740336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RR旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是Mar，“**麻烦结点**”Nov在发现者**右**子树的**右**边，因而叫RR插入，需要RR旋转（右单旋）。
基本思路是把B的左子树腾出来挂到A的右子树上，再将A挂在B的左子树上，返回B作为当前子树的根，如图：
![RR旋转](https://img-blog.csdnimg.cn/20210523193647282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RR旋转"){:width=150px height=150px}
```
AVLTree RRRotation(AVLTree A)
{
    // 此时根节点是A
	AVLTree B = A->right;   // B为A的右子树  
	A->right = B->left;    // B的左子树挂在A的右子树上 
	B->left = A;   //  A挂在B的左子树上 
	return B;  // 此时B为根结点   
}
```
[LR旋转](#lr旋转)
[RL旋转](#rl旋转)
RR旋转的结果是：根节点的右子节点成为新的根节点，旧根节点成为新根节点的左子节点
###### LL旋转
设有下图左边所示的平衡二叉树，当在其左子树的左边插入元素Apr时二叉树变为如下图中间所示的情况，由于左孩子结点Mar的平衡因子变为2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素Mar、Aug、Apr处于平衡状态，采用LL旋转，得到下图右边所示的平衡二叉树。
![LL旋转例](https://img-blog.csdnimg.cn/20210523165405872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LL旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是Mar，“**麻烦结点**”Apr在发现者**左**子树的**左**边，因而叫LL插入，需要LL旋转（左单旋）。
基本思路是把B的右子树腾出来挂上A的左子树，再将A挂在B的右子树上，返回B作为当前子树的根，如下图所示。
![LL旋转](https://img-blog.csdnimg.cn/20210523192943479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LL旋转"){:width=150px height=150px}
```
AVLTree LLRotation(AVLTree A)
{
	// 此时根节点是A 
	AVLTree B = A->left;  // B为A的左子树  
	A->left = B->right;   // B的右子树挂在A的左子树上 
	B->right = A;     //  A挂在B的右子树上 
	return B;  // 此时B为根结点 
}
```
[LR旋转](#lr旋转)
[RL旋转](#rl旋转)
LL旋转的结果是：根节点的左子节点成为新的根节点，旧根节点成为新根节点的右子节点
###### LR旋转
假设有下图左边所示的平衡二叉树，当在其左子树的右边插入元素Jan时二叉树变为如下图中间所示的情况，由于根结点May的平衡因子变为2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素May、Aug、Mar处于平衡状态，采用LR旋转，得到下图右边所示的平衡二叉树。
![LR旋转例](https://img-blog.csdnimg.cn/20210523164920245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LR旋转例"){:width=150px height=150px}
不平衡的“**发现者**”是May，“**麻烦结点**”Jan在左子树的右边，因而叫LR插入，需要LR旋转。
基本思路是先将B作为根结点进行[RR旋转](#rr旋转)（将C的左子树腾出来挂到B的右子树上，再将B挂在C的左子树上），再将A作为根结点进行[LL旋转](#ll旋转)（把C的右子树腾出来挂到A的左子树上，再将A挂在C的右子树上），即先进行RR旋转再进行LL旋转，如下图所示。
![LR旋转](https://img-blog.csdnimg.cn/20210523192652494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "LR旋转"){:width=150px height=150px}
```
AVLTree LRRotation(AVLTree A)
{
	A->left = RRRotation(A->left); // 先RR旋转
	return LLRotation(A); // 再LL旋转 
}
```
###### RL旋转
假设有下图左边所示的平衡二叉树，当在其左子树结点的右边孩子节点的左边插入元素Feb时二叉树变为如下图中间所示的情况，由于左孩子结点Aug的平衡因子变为-2，所以二叉树不平衡了，需要进行调整。调整的关键是使得元素Aug、Jan、Dec处于平衡状态，采用RL旋转，得到下图右边所示的平衡二叉树。
![RL旋转例](https://img-blog.csdnimg.cn/20210523165304373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RL旋转例"){:width=150px height=150px}
RL旋转的基本思路是先将B作为根结点进行[LL旋转](#ll旋转)（将C的右子树腾出来挂到B的左子树上，再将B挂在C的右子树上），再将A作为根结点进行[RR旋转](#rr旋转)（将C的左子树腾出来挂到A的右子树上，再将A挂在C的左子树上），即先进行LL旋转再进行RR旋转，如下图所示。
![RL旋转](https://img-blog.csdnimg.cn/20210523193159779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "RL旋转"){:width=150px height=150px}
```
AVLTree RLRotation(AVLTree A)
{
	A->right = LLRotation(A->right); // 先LL旋转
	return RRRotation(A); // 再RR旋转 
}
```
##### AVL树的根
AVL树是一种自平衡二叉搜索树，在AVL树中任何结点的两个子树的高度最多相差1。假设由于在二叉搜索树上插入结点而失去平衡，则需要进行调整以恢复此属性，如下图所示
![AVL树的根](https://img-blog.csdnimg.cn/20210523202827112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "AVL树的根"){:width=300px height=300px}
预先定义代码：
```
int Max(int a, int b) // 返回最大值 
{
	return a > b ? a : b;
}
int getHeight(AVLTree A) // 返回树高，若该节点为叶节点则返回0，空树返回-1（与叶节点做区分）
{
	return A == NULL ? -1 : A->height;
}
//以及4种旋转
```
求根节点为T的AVL树插入新节点x后的新根节点：思路类似[二叉搜索树的插入](#插入)，要先根据数据大小判断插入到左/右子树，再递归插入；同时为确保平衡，当不平衡时要根据插入的位置进行旋转；最后不要忘了更新节点的高度
```
AVLTree Insert(AVLTree T, int x)
{
	if (!T)  // 如果该结点为空，初始化结点
	{
		T = (AVLTree)malloc(sizeof(struct AVLNode));
		T->data = x;
		T->left = NULL;
		T->right = NULL;
		T->height = 0;
	}
	else   // 否则不为空
	{
		if (x < T->data)  // 左子树
		{
			T->left = Insert(T->left, x);
			if (getHeight(T->left) - getHeight(T->right) == 2)   //如果左子树和右子树高度差为2（因为插入到左子树，肯定左子树树高>右子树）
			{
				if (x < T->left->data)  //x应插入到根节点左子树的左侧--LL旋转 
					T = LLRotation(T); //旋转后要更新根节点
				else if (x > T->left->data)  //x应插入到根节点左子树的右侧--LR旋转
					T = LRRotation(T);
			}
		}
		else if (x > T->data)   // 右子树
		{
			T->right = Insert(T->right, x);
			if (getHeight(T->right) - getHeight(T->left) == 2)
			{
				if (x < T->right->data)  //x应插入到根节点右子树的左侧--RL旋转 
					T = RLRotation(T);
				else if (x > T->right->data)  //x应插入到根节点右子树的右侧--RR旋转
					T = RRRotation(T);
			}
		}
	}
	//更新树高 
	T->height = Max(getHeight(T->left), getHeight(T->right)) + 1;
	return T;
}
```
### 堆
堆(Heap)是计算机科学中一类特殊的数据结构的统称，通常是一个可以被看做一棵完全二叉树的数组对象。
堆总是满足下列**性质**：
- 堆中某个结点的值总是不大于或不小于其父结点的值；
- 堆总是一棵**完全二叉树**。

堆是**非线性数据结构**，相当于一维数组，有两个直接后继。
***
优先队列(Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的**优先权(关键字)大小**，而不是元素进入队列的先后顺序。
优先队列的完全二叉树表示：![优先队列的完全二叉树表示](https://img-blog.csdnimg.cn/20210528103433896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "优先队列的完全二叉树表示"){:width=150px height=150px}
***
堆的两个**特性**：
- **结构性**：堆是用数组表示的完全二叉树；
- **有序性**：任一结点的关键字是其子树所有结点的最大值(或最小值)。
根节点为最大值的称为“最大堆(MaxHeap)”，也称“大顶堆”：
![最大堆](https://img-blog.csdnimg.cn/20210528110304418.png#pic_center "最大堆"){:width=100px height=100px}
根节点为最小值的称为“最小堆(MinHeap)”，也称“小顶堆”：
![最小堆](https://img-blog.csdnimg.cn/20210528110320280.png#pic_center "最小堆"){:width=100px height=100px}
##### 最大堆操作
###### 初始化
最大堆的数据结构定义:
```
typedef struct HeapStruct* MaxHeap;
struct HeapStruct {
    ElementType *Elements;  //存储堆元素的数组
    int Size;  //堆的当前元素个数
    int Capacity;  //堆的最大容量
};
```
初始化最大堆：因为堆是完全二叉树，所以堆数组从索引为1的位置开始存储元素，所以申内存时要Maxsize+1；堆数组的第一个元素不存储有效数据，于是用来存放最大值
```
MaxHeap Create(int Maxsize)  //创建容量为MaxSize的空的最大堆
{
    MaxHeap H = malloc(sizeof(struct Heapstruct));
    H->Elements = malloc((Maxsize+1) * sizeof(ElementType));
    H->Size = 0 ;
    H->Capacity = Maxsize;
    H->Elements [0] = MaxData;  //定义“哨兵”MaxData为大于堆中所有可能元素的值，便于以后更快操作
    return H;
}
```
基础操作：
```
// 判断是否已经满 
bool IsFull(MaxHeap H) 
{
	return (H->Size == H->Capacity);
}
// 判断是否为空
bool IsEmpty(MaxHeap H) 
{
	return !H->Size;
}
```
###### 插入
如图的5个元素：
![最大堆插入1](https://img-blog.csdnimg.cn/20210528154907578.png#pic_center "最大堆插入1"){:width=100px height=100px}
现要向其中插入1个元素，最简单的想法就是把它放入堆数组的最后1个位置，即上图`[6]`的地方；
插入后需判断符不符合堆的性质：只要插入的那个元素<它的父节点就满足；如果不满足，就交换它与它的父节点，交换后，还要再比较它与它的新父节点。
![最大堆插入2](https://img-blog.csdnimg.cn/20210528114246197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "最大堆插入2"){:width=300px height=300px}
核心算法：将新增结点插入到从其父结点到根结点的有序序列中。
为提高速度，当不满足堆性质时，我们不使用交换的方式，而是让新数的父节点覆盖它的位置，直到新数<=它的父节点，循环结束，把新数写到空缺的那个位置上
```
void Insert(MaxHeap H, ElementType item) //插入
{
    int i;
    if (IsFull(H)) 
    {
        cout << "最大堆已满" << endl;
        return;
    }
    i = ++H->Size; //i表示新数要插入到堆数组的位置（原来的size+1的位置）
	//同时堆的size也要增大1、
	//新数位置是H->Elements[i]，它的父节点是H->Elements[i/2]
    for (; H->Elements[i/2]<item; i/=2)  //i每/2，就是向上推进一层
	//循环持续条件：新数>它的父节点
        H->Elements[i] = H->Elements[i/2]; //覆盖新数的位置
	//循环结束时，i/2是它的父节点，i就是它应该在的位置
    H->Elements[i]= item;  //item插入
}
```
不用担心死循环的问题，因为i肯定会有==1的时候，`1/2`就是0，`Elements[0]`是最大值，item肯定<最大值
[哈夫曼树的构造](#哈夫曼树的构造)
###### 删除
删除堆的根节点（最大的那个元素），并将删除的节点值返回。
思路：在根节点删除后，将堆数组的最后1个元素移到根节点；为确保堆的有序性，找出这个元素较大的子节点，若比它大，就将它们交换；重复上述过程，直到这个元素较大的子节点也小于它。
例： 在下图所示的树中删除元素58的情况如下图所示
![最大堆删除](https://img-blog.csdnimg.cn/20210528154717300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "最大堆删除"){:width=250px height=100px}
```
ElementType DeleteMax(MaxHeap H) //删除
{
    int Parent,Child;
    ElementType MaxItem, temp;
    if (IsEmpty(H)) 
    {
        cout << "最大堆已为空" << endl;
        return ;
    }
    MaxItem = H->Elements[1];  //保存原根结点最大值
    temp = H->Elements [H->size--];  //拿到完全二叉树最后一个元素，同时堆的size-1
	//接下来需要找temp的位置，同时完成新根节点的赋值
	//使用Parent表示temp应该在的位置（初始为1即根节点），按照上面的思路，应该让temp与它的子节点Child比较
    for(Parent=1; Parent*2<=H->size; Parent=Child)   //大结束条件：Parent没有左儿子(Parent*2<=H->size)
    {
        Child = Parent * 2; //Parent的右儿子就是child+1
        if((Child!=H->Size)&&(H->Elements[Child]<H->Elements[Child+1]))  //Child!=H->Size表示Child不为当前最后一个结点，即Parent有右孩子结点
            Child++;  //让Child指向左右子结点的较大者
        //给temp找个合适的位置 
        if(temp>=H->Elements[Child])   //如果temp较大的子节点也小于它，说明temp位置已经合适
            break ;
        else  //位置不合适时
        H->Elements[Parent]=H->Elements[Child]; //让较大的子节点移动到它的位置
		//同时Parent=Child移动到下一层进行判断
    }
    H->Elements [Parent] = temp;  //在合适的位置把temp放进去
    return MaxItem;
}
```
[哈夫曼树的构造](#哈夫曼树的构造)
###### 建立
建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。
- 第一种方法：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，时间复杂度`O(NlogN)`，因为插入一个元素的时间复杂度为`O(logN)`
- 更好的方法：
	1. 将N个元素按输入顺序存入，先满足**完全二叉树的结构特性**；
	2. 调整各结点位置，以满足**最大堆的有序特性**。
   
	这种方法的时间复杂度为`O(n)`

任何调整各结点位置使其成堆：
- 从堆的删除出发，删除最大值实际就是在根节点的左右子树都是堆的基础上，指定根节点为某个数，经过调整使它们整体重新成堆的过程；
- 于是可以从倒数第一个有子节点的父节点开始，因为它的左右子树至多都只有1个元素，所以满足堆删除的条件，因此可以用上述思路把这个父子结构调成小堆，依此类推，从下至上，把所有父节点都调成堆

```
// 排序，类似堆的"删除操作" 
void sort(MaxHeap H, int i)  //将父节点索引为i的子堆调整为最大堆
{
	int Child, Parent;
	int temp = H->data[i];  //设根节点数为H->data[i]，即传入的父节点
	for (Parent = i; Parent * 2 <= H->size; Parent = Child) //传入根节点在总堆数组的初始位置为i，照应上面删除代码中Parent=1
	{ //循环体内代码同前
		Child = 2 * Parent;
		if ((Child != H->size) && (H->data[Child] < H->data[Child + 1]))
			Child++; 
		if (temp >= H->data[Child])
			break;
		else
			H->data[Parent] = H->data[Child];
	}
	H->data[Parent] = temp;
}
// 最大堆的建立(调整H->Data[]中的元素，使满足最大堆的有序性)
void BuildHeap(MaxHeap H) 
{
	for (int i = H->size / 2; i > 0; i--)  //从最后一个结点的父节点开始，到根结点1
	{
		sort(H, i); //以每个有孩子结点的结点作为根结点，对其子树进行堆排序 
	}
}
//主函数调用
int main() 
{
	MaxHeap H;
	H = Create();
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> H->data[++H->size]; //注意要初始化size
	BuildHeap(H);
	return 0;
}
```
**注意：堆的操作实际上都是通过改变堆数组来实现**
[哈夫曼树的构造](#哈夫曼树的构造)
### 哈夫曼树和哈夫曼编码
##### 哈夫曼树
###### 权值
将百分制的考试成绩转换成五分制的成绩：
```
if(score < 60 ) grade = 1;
else if(score <70 ) grade = 2;
else if( score < 80 ) grade = 3;
else if( score <90 ) grade = 4;
else grade = 5;
```
最简单的判定树：
![最简单的判定树](https://img-blog.csdnimg.cn/20210528222855858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "最简单的判定树"){:width=150px height=150px}
优化一下：
![优化判定树](https://img-blog.csdnimg.cn/20210528223257858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "优化判定树"){:width=150px height=150px}
我们将已知数据与每个结点代表的值进行比较，决定去左子树还是右子树，并得到最后的结果。这里的`80` `90` `70` `60`就称为结点的权值。
###### 哈夫曼树的定义
**带权路径长度(WPL)**：设二叉树有n个叶子结点，每个叶子结点带有权值w~k~，从根结点到每个叶子结点的长度为l~k~，则每个叶子结点的WPL=$\sum_{k=1}^n{w_kl_k}$
**最优二叉树或哈夫曼树**： WPL最小的二叉树。
例：有五个叶子结点，它们的权值为{1,2,3,4,5}，用此权值序列可以构造出形状不同的多个二叉树，如下图所示：
![WPL的计算](https://img-blog.csdnimg.cn/20210529093548904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "WPL的计算"){:width=300px height=300px}
###### 哈夫曼树的构造
核心思路：**每次把权值最小的两棵二叉树合并**，如下图所示：
![哈夫曼树的构造](https://img-blog.csdnimg.cn/20210529094236952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "哈夫曼树的构造"){:width=300px height=150px}
`1`和`2`结点合并在一起，得到一个新结点，新节点的权值是它们的和，即`3`；现在有`3 3 4 5`4个权值，再合并最小的两个权值，新结点权值为`6`；`6 4 5`->`6 9`->`15`。
***
其中面临的主要问题就是如何选取两个最小的数--构造一个最小堆：
这个堆的堆数组存放哈夫曼树的节点，哈夫曼树的节点存放它的权值；
首先使用[堆的构造函数](#建立)，根据权值将堆数组调为最小堆；
之后进行`size-1`次循环（`size`个数，两两合并），将堆进行合并--每次循环都构造一个新节点，它的左/右子节点是堆的最小值（最小堆的根节点）--这里使用[堆的删除](#删除-1)，它的权值就是左右子节点权值的和；新节点构造完成后将它[插入](#插入-1)到最小堆；
循环结束后，最小堆中只剩一个元素，使用堆删除函数清空最小堆，并返回根节点。根节点中存放左右子节点的信息，可以通过根节点回推整个哈夫曼树的结构。
```
typedef struct TreeNode *HuffmanTree;
struct TreeNode {
    int weight; //权值
    HuffmanTree Left,Right;
}    
HuffmanTree Huffman(MinHeap H)
{
    int i;
    HuffmanTree T;
    BuilGMinHeap(H);  //将H->Elements[]按权值调整为最小堆
    for(i = 1; i <H->Size; i++)  //做H->Size-1次合并
    {  
        T = malloc(sizeof(struct TreeNode));  //建立新结点
        T->Left = DeleteMin(H);  //从最小堆中删除一个结点,作为新T的左子结点
        T->Right = DeleteMin(H);  //从最小堆中删除一个结点,作为新T的右子结点
        T->weight =T->Left->weight + T->Right->weight;  //计算新权值
        Insert(H,T);  //将新T插入最小堆
    }
    T = DeleteMin(H);
    return T;
}
```
时间复杂度为`O(NlogN)`，要快于每次合并节点时通过排序取出最小的两个数。
[完整代码](./附录1：哈夫曼树.md)
###### 哈夫曼树的特点
1. 没有度为1的结点（只有一个子树的节点）；
2. 有n个叶结点的哈夫曼树共有`2n-1`个结点；
	n~0~：叶结点总数
	n~1~：只有一个儿子的结点总数（没有度为1 的结点，n~1~=0）
	n~2~：有2个儿子的结点总数（[n~0~=n~2~+1](#性质)）
	总结点数：n~0~+n~1~0+n~2~=2n~0~-1
3. 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树；
4. 对同一组权值可能存在不同构的两棵哈夫曼树，它们都有相同的WPL值。
	例：对一组权值{1,2,3,3}，不同构的两棵哈夫曼树如下图所示：
	![哈夫曼树的特点](https://img-blog.csdnimg.cn/20210529100658310.png#pic_center "哈夫曼树的特点"){:width=100px height=100px}
##### 哈夫曼编码
给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最少？
例： 假设有一段文本，包含58个字符，并由以下7个字符构成：`a,e,i,s,t,空格(sp),换行(nl)`；这7个字符出现的次数不同。
1. 用等长ASCII编码：58×8=464位；
2. 用等长3位编码：58×3=174位；
3. 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则可以编码长些。

问题：怎么进行不等长编码？如何避免二义性（同样的编码有多种解码方式）？
只要使用**前缀码(prefix code)**：任何字符的编码都不是另一字符编码的前缀，可以无二义地解码。
***
二叉树用于编码：
1. 左右分支代表0、1；
2. 字符只在叶结点上。

只要满足**字符只在叶结点上**就可以形成前缀码
例：四个字符的频率：`a:4,u:1,x:2,z:1`，如下图所示：
![二叉树用于编码](https://img-blog.csdnimg.cn/2021052910205473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_16,color_FFFFFF,t_70#pic_center "二叉树用于编码"){:width=250px height=250px}
可以看到，每个字符编码长度=它所在的叶节点距根节点的路径长度l~k~，总长度=l~k~*出现次数，设每个字符的出现次数为对应节点的权值w~k~，则总长度就是这个哈夫曼树的WPL
### 集合
##### 集合的表示
**集合运算**：求两个集合的交集、并集、补集、差集，以及判定一个元素是否属于某一集合。
**并查集**：合并集合、查找某元素属于什么集合。
例：有10台电脑`{1,2,3,...,9,10}`，已知下列电脑之间
已经实现了连接：1和2、2和4、3和5、4和7、5和8、6和9、6和10
问:2和7之间、5和9之间是否是连通的？
解决思路：
1. 将10台电脑看成10个集合`{1},{2},{3},...,{9},{10}`；
2. 当已知一种连接`x和y`时,就将x和y对应的集合合并；
3. 查询“x和y是否是连通的”就是判别x和y是否属于同一集合。

其中涉及到了集合的合并以及查询操作，即并查集
***
并查集问题中集合存储如何实现？
- 可以用树结构表示集合，树的每个结点代表一个集合元素。

例如，有三个整数集合`S1={1,2,4,7}`、`S2={3,5,8}`、`S3={6,9,10}`。
![双亲表示法](https://img-blog.csdnimg.cn/20210529155327212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVQUlfQklfVE9ORw==,size_13,color_FFFFFF,t_70#pic_center "双亲表示法"){:width=200px height=200px}
即每个树的叶子节点的指针域只保存指向根节点的指针。
在此基础上优化存储形式，采用数组进行存储：
![双亲表示法数组存储](https://img-blog.csdnimg.cn/20210529160849510.png#pic_center "双亲表示法数组存储"){:width=200px height=200px}
其中`Parent`列负数表示它是根结点，非负数表示它双亲结点的下标。
如`data=1`的parent=-1，就说明它是根节点；`data=2/4/7`的parent都=0，就说明它们的父节点是下标为0的元素`data=1`.
数组中每个元素的类型描述为：
```
#define Maxsize 1000 //全局变量，为数组S的最大长度
typedef struct {
    ElementType Data;
    int Parent;
} SetType;
// 初始化数组，父结点全部指向-1 
for (int i = 0; i < MaxSize; i++) 
{
	S[i].Data = i + 1; //设存储数据为1,2,..,MaxSize
	S[i].Parent = -1;
}
```
##### 集合运算
###### 查找某个元素所在的集合
```
int Find(SetType S[], ElementType X) //找到X所属集合，返回该集合根结点在数组S中的下标
{   
    int i;
	//先遍历整个数组，找这个元素在数组S中的下标
    for (i=0 ; i < Maxsize && S[i].Data != X; i++);  //当S[i].Data = X时，循环结束，i为X的位置下标
    if(i >= Maxsize)  return -1;  //未找到X，返回-1 
	//
    for (; S[i].Parent >= 0; i = S[i].Parent);  //已确定X存在，就寻找它的父结点，直到这个父节点为根节点，即S[i].Parent<0为止（根结点的Parent为-1）
    return i;  //返回下标
}
```
###### 合并集合
思路：
- 分别找到X1和X2两个元素所在集合树的根结点；
- 如果它们不同根，则将其中一个根结点的parent指针设置成另一个根结点的数组下标。

```
void Union(SetType S[], ElementType X1, ElementType X2) //将数组S中X1和X2两个元素所在集合合并
{
    int Root1, Root2;
    Root1 = Find(S, X1); //Root1/2为这两个元素所在集合根节点在S中的下标
    Root1 = Find(S, X2);
    if (Root1 != Root2)  //当x1和x2不属于同一子集时，才需要合并
       S[Root2].Parent = Root1;  
}
```
这种写法便于理解，但它直接把一个集合的根节点挂在另一个集合下，使树越来越高（层数增多），进而导致查找Find函数效率降低。
###### 合并集合的改进
采用将较小集合放入较大集合中的方法，这需要知道每个集合中有多少个元素，该信息只需由根节点存储：
如果在结构定义中增加一个变量，会导致空间浪费；于是使用根节点的parent值记录：
`parent=-n`即表示节点是根节点(parent<0)，又表示该集合中有n个元素
```
void Union(SetType S[], SetName Root1, SetName Root2)
{   //这里默认Root1和Root2是不同集合的根结点下标
    //让小集合并入大集合
    if ( S[Root2].Parent < S[Root1].Parent ) {  //如果集合2比较大
        S[Root2].Parent += S[Root1].Parent; //集合1并入集合2，集合2数量增加
        S[Root1].Parent = Root2; //改变集合1parent指针指向
    }
    else {                         //如果集合1比较大
        S[Root1].Parent += S[Root2].Parent;     //集合2并入集合1
        S[Root2].Parent = Root1;
    }
}
```