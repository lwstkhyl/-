数据的查找：给定关键字K，从集合中找出关键字与K相同的记录
静态查找：集合中记录是固定的，没有插入和删除操作，只有查找
动态查找：集合中记录是动态变化的，可能发生插入和删除

如果把数据放在一个数组中，最简单的方法是顺序查找，即依次比较数组中的元素与给定关键字是否相等，其时间复杂度为O(n)，当n很大时速度慢
更快的方法是二分查找，若n个数据元素的关键字满足有序（可以进行比较），且连续存放（放在数组中），则可以进行二分查找。
例如有13个元素，二分查找关键字为444的元素（是第12个元素）过程：开始时left=1，right=13，mid=(1+13)/2=7，第7个元素=100<444，说明444肯定在mid-right段内；left=8，right=13，mid=10，第10个元素321<444，说明444在11-13范围内；left=11，right=13，mid=12，找到了。如果查找的元素不存在，最后一步会出现left>right的情况，可以判断元素不存在

二分查找算法：
int er_fen_cha_zhao(int a[], int n, int k)//a为给定数组，n为数组大小，k为想找的数
{
	int left, right, mid, no_found = -1;
	left = 0;
	right = n - 1;//初始的左右边界
	while (left <= right)
	{
		mid = (left + right) / 2;  
		if (k < a[mid]) right = mid - 1;  //调整右边界
		else if (k > a[mid]) left = mid + 1;  //调整左边界
		else return mid;  //查找成功，返回下标
	}
	return no_found;
}
该算法每次都把查找范围缩小一半，则循环的次数也会除以2，所以时间复杂度为O(logn)

可以知道，二分查找的查找过程是一定的，都是通过与mid的元素的比较来进行判断，该过程可以写成分支结构的形式，称为二分查找的判定树，树上每个数值（数组中元素的位置）是一个结点，判定树上每个结点需要的查找次数刚好是该结点所在的层数。该树总的层次是[lgn]+1  ([]为取整）。平均成功查找次数（ASL)=(要找n次的数有几个*n,求和）/数的总个数


树（tree）：n个结点构成的有限集合；当n=0时，称为空树；对于任一棵非空树，有以下性质：
1、树中有一个称为根（root）的特殊结点，用r表示
2、其余结点可分为m（m>0）个互不相交的有限集T1、T2、...Tm，其中每个集合本身又是一棵树，称为原来树的“子树”（subTree）
若A有BCD三个分支，当B与C相连时，就不是树；若B有E的分支，C与E相连，也不是树，所以
1、子树是不相交的
2、除了根结点外，每个结点有且仅有一个父结点
3、一棵有N个结点的树有N-1条边（边就是连接两个结点的线），树是保证每个结点联通的最小的一种连接方式

树的一些基本术语：
1、结点的度（degree）：结点的子树个数
2、树的度：树的所有结点中最大的度数
3、叶结点（leaf）：度为0的结点
4、父结点（parent）：有子树的结点是其子树的根节点的父结点
5、子结点（孩子结点）（child）：若A结点是B结点的父节点，则称B结点为A结点的子结点
6、兄弟结点（sibling）：具有同一父结点的各结点彼此是兄弟结点
7、路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,...,nk，ni是ni+1的父结点。路径所包含边的个数为路径的长度
8、祖先结点（ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
9、子孙结点（descendant）：某一结点的子树中的所有结点是这个结点的子孙
10、结点的层次（level）：规定根结点在1层，其他任一结点的层数是其父结点的层数加1
11、树的深度（depth）：树中所有结点中的最大层次

树的表示：用链表进行实现，可以是”一个结点有几个子节点，它就有几个指针“这种结构，但这种结构中每个结点的指针域都不同；也可以把所有结点的指针个数都设为同一值，即子树的最大个数，子树数量少的结点中把没用的指针设为null，但这样会多使用指针，造成空间上的浪费；

儿子-兄弟表示法：每个结点都有两个指针，其中first_child指针指向它的第一个儿子，next_sibling指针指向它的下一个兄弟
A->n  (n为空指针,->是next_sibling,↓是first_child)
↓
B-------------->C--------->D->n 
↓               ↓          ↓ 
E----->F->n     G->n       H--->I----->J-->n 
↓      ↓        ↓          ↓    ↓      ↓
K->L->n n       n          M     n     n
↓  ↓                       ↓
n  n                       n

这种方法的空间浪费更少（n个结点，2n个指针，共n-1条边，空的指针只有n+1个）
把指针的指向看成一棵树，每一个结点都有两个指针，最多有两个儿子（两个指针都不为空），这种树称为二叉树，它的度为2。把上表以A为轴心顺时针转45°，↓即first_child可以看成往左的指针（左儿子），->即next_sibling可以看成往右的指针（右儿子）



